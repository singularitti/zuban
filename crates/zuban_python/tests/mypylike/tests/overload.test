[case overload_not_overlapping_none]
from typing import overload, Any

@overload
def f(x: None) -> object: ...
@overload
def f(x: str) -> str: ...
@overload
def f(x: Any) -> str: ...
def f(x): pass

[case overload_unmatchable_none_strict_optional]
from typing import overload, Any

@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_unmatchable_none]
# flags: --no-strict-optional
from typing import overload, Any

@overload
def g(x: str) -> object: ...
@overload
def g(x: None) -> str: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def g(x: Any) -> str: ...
def g(x): pass

[case overload_not_overlapping_optional]
from typing import overload, List, Dict, Optional, Sequence, Union, Tuple

@overload
def f(a: List[Dict]) -> List[int]: # E: overloaded function signatures 1 and 2 overlap with incompatible return types
    ...

@overload
def f(a: List[Optional[Dict]]) -> List[Optional[int]]:
    ...

def f(
    a: Union[List[Dict], List[Optional[Dict]]]
) -> Union[List[int], List[Optional[int]]]:
    return [1]

[case overload_overlapping_any]
from typing import overload, TypeVar, Any

T = TypeVar("T")

@overload
def f(x: T) -> T: pass
@overload
def f(x: Any) -> Any: pass
@overload
def f(x: Any) -> Any: pass  # E: Overloaded function signature 3 will never be matched: signature 2's parameter type(s) are the same or broader
def f(x: Any) -> Any: pass

[case overload_merging_nested]
from typing import overload, Any
@overload
def g(x: str) -> list[list[str]]: ...
@overload
def g(x: int) -> list[list[int]]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[list[Any]]"

[case overload_merging_triple1]
from typing import overload, Any
@overload
def g(x: str) -> list[str]: ...
@overload
def g(x: int) -> list[int]: ...
@overload
def g(x: bytes) -> list[bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "list[Any]"

[case overload_merging_triple2]
from typing import overload, Any
@overload
def g(x: str) -> str: ...
@overload
def g(x: int) -> int: ...
@overload
def g(x: float) -> bytes: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "Any"

[case overload_merging_tuple1]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple2]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any]"

[case overload_merging_tuple3]
from typing import overload, Any
@overload
def g(x: str) -> tuple[str, bytes]: ...
@overload
def g(x: int) -> tuple[int]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[Any, ...]"

[case overload_merging_tuple4]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, ...]: ...
@overload
def g(x: int) -> tuple[int, ...]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, ...]"

[case overload_merging_tuple5]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, str]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, str]"

[case overload_merging_tuple6]
from typing import overload, Any
@overload
def g(x: str) -> tuple[int, str]: ...
@overload
def g(x: int) -> tuple[int, bytes]: ...
def g(x): pass

a: Any
reveal_type(g(a)) # N: Revealed type is "tuple[int, Any]"

[case overload_with_callable_type_var_mypy_issue_13436]
from typing import Any, Callable, overload, TypeVar
C = TypeVar("C", bound=Callable[..., object])

@overload
def wrapper(arg: C) -> C: ...
@overload
def wrapper(arg: object) -> object: ...
def wrapper(arg: object) -> object: ...

def case_a(x: int) -> None: pass

reveal_type(case_a)           # N: Revealed type is "def (x: int)"
reveal_type(wrapper(case_a))  # N: Revealed type is "def (x: int)"

def case_b(x: Any) -> None: pass

reveal_type(case_b)           # N: Revealed type is "def (x: Any)"
reveal_type(wrapper(case_b))  # N: Revealed type is "def (x: Any)"

[case overload_union_math_on_class_init_constrained]
from typing import Callable, Union, overload, Generic, TypeVar
T = TypeVar("T", str, int)

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[int] | __main__.Foo[str]"

[case overload_union_math_on_class_init_unconstrained]
from typing import Callable, Union, overload, Generic, TypeVar
T = TypeVar("T")

class Foo(Generic[T]):
    @overload
    def __init__(self, x: int, y: T): ...
    @overload
    def __init__(self, x: T, y: str): ...
    def __init__(self, x, y): ...

u1: int | str
reveal_type(Foo(1, "")) # N: Revealed type is "__main__.Foo[str]"
reveal_type(Foo(1, u1)) # N: Revealed type is "__main__.Foo[int | str]"

[case multi_dimension_union_math_issue_13595]
# Taken from mypy #13595
from typing import Union, overload

@overload
def f(x: int, y: int) -> None: ...
@overload
def f(x: str, y: int) -> None: ...
@overload
def f(x: int, y: str) -> None: ...
@overload
def f(x: str, y: str) -> None: ...
def f(x, y) -> None: ...

a: Union[int, str]
b: Union[int, str]
f(a, b) # This is valid

[case overload_class_type_var_implementation_match_and_mismatch]
from typing import TypeVar, Callable, Union, overload, Generic, Optional
T = TypeVar("T")
U = TypeVar("U")

class Foo(Generic[T]):
    @overload
    def foo(self, x: int) -> T: ...
    @overload
    def foo(self, x: str) -> Optional[T]: ...
    @overload
    def foo(self, x: U, y: int) -> Optional[U]: ...
    def foo(self, x, y=None) -> Optional[T]: ... # E: Overloaded function implementation cannot produce return type of signature 3

[case overload_michi_valid_implementation]
# Originally raise by Michi. This should theoretically not lead to errors, but
# Mypy and Zuban both just compare the named parameters, which leads to this
# error.
from typing import overload

@overload
def oof(fn: int) -> int: ...

@overload
def oof(fn2: bytes) -> bytes: ...

def oof(fn: int | bytes | None = None, fn2: bytes | None = None) -> bytes | int: raise NotImplementedError # E: Overloaded function implementation does not accept all possible arguments of signature 2

[case overload_check_defaults_for_implementation_only]
from typing import overload

@overload
def foo(x: int) -> int: ...
@overload
def foo(x: str = ...) -> str: ...
def foo(x: int | str = b"") -> str | int: ... # E: Incompatible default for argument "x" (default has type "bytes", argument has type "int | str")

[case overload_with_self_types_fallback]
# Inspired by testOverloadAndSelfTypesGenericNoOverlap
from typing import overload, Self, Any

class C:
    @overload
    def get(self, obj: None) -> Self: ...
    @overload
    def get(self, obj: int) -> Self: ...
    def get(self, obj) -> Self:
        return self

any: Any
class D(C): ...
d: D
reveal_type(d.get(None))  # N: Revealed type is "__main__.D"
reveal_type(d.get(""))  # E: No overload variant of "get" of "C" matches argument type "str" \
                        # N: Possible overload variants: \
                        # N:     def get(self, obj: None) -> Self \
                        # N:     def get(self, obj: int) -> Self \
                        # N: Revealed type is "Any"

[case overload_with_self_types_union_math]
# Inspired by testOverloadAndSelfTypesGenericNoOverlap
from typing import overload, Self, Any

class C:
    @overload
    def get(self, obj: None) -> Self: ...
    @overload
    def get(self, obj: int) -> int: ...
    def get(self, obj) -> Self | int:
        return self

u: int | None
class D(C): ...
d: D
reveal_type(d.get(u))  # N: Revealed type is "int | __main__.D"

[case overload_classmethod_without_self_type]
# Like testSelfTypeClassMethodOverloadedOnInstance, but without first annotations.
from typing import Optional, Type, TypeVar, overload, Union

Id = int

class AClass:
    @overload
    @classmethod
    def delete(cls, id: Id, id2: Id) -> Optional[int]: ...

    @overload
    @classmethod
    def delete(cls, id: AClass, id2: None = None) -> Optional[int]: ...

    @classmethod
    def delete(cls, id: Union[AClass, Id], id2: Optional[Id] = None) -> Optional[int]:
        ...

def foo(x: Type[AClass]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int, id2: int) -> Union[int, None], def (id: __main__.AClass, id2: None =) -> Union[int, None])"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: int, id2: int) -> Union[int, None], def (id: __main__.AClass, id2: None =) -> Union[int, None])"
    y.delete(10, 20)
    y.delete(y)

def bar(x: AClass) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int, id2: int) -> Union[int, None], def (id: __main__.AClass, id2: None =) -> Union[int, None])"
    x.delete(10, 20)

[case self_type_filtering_of_classmethod_overload]
from typing import Optional, Type, TypeVar, overload, Union, Generic, Any

T = TypeVar("T")

class A(Generic[T]):
    @overload
    @classmethod
    def delete(cls: Type[A[int]], id: int) -> int: ...

    @overload
    @classmethod
    def delete(cls: Type[A[str]], id: str) -> str: ...

    @overload
    @classmethod
    def delete(cls: Type[A[str]], id: bytes) -> bytes: ...

    @classmethod
    def delete(cls, id) -> Any:
        ...

def foo_no_generics(x: Type[A]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(y.delete(10))  # N: Revealed type is "int"

def bar_no_generics(x: A) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: int) -> int, def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(x.delete(""))  # N: Revealed type is "str"

def foo_str(x: Type[A[str]]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "Overload(def (id: str) -> str, def (id: bytes) -> bytes)"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "Overload(def (id: str) -> str, def (id: bytes) -> bytes)"
    reveal_type(y.delete(10))  # E: No overload variant of "delete" of "A" matches argument type "int" \
                               # N: Possible overload variants: \
                               # N:     def delete(cls, id: str) -> str \
                               # N:     def delete(cls, id: bytes) -> bytes \
                               # N: Revealed type is "Any"
    reveal_type(y.delete(b''))  # N: Revealed type is "bytes"

def foo_int(x: Type[A[int]]) -> None:
    reveal_type(x.delete)  # N: Revealed type is "def (id: int) -> int"
    y = x()
    reveal_type(y.delete)  # N: Revealed type is "def (id: int) -> int"
    reveal_type(y.delete(10))  # N: Revealed type is "int"

def foo_something_else(x: Type[A[list[int]]]) -> None:
    reveal_type(x.delete)  # E: Invalid self argument "type[A[list[int]]]" to attribute function "delete" with type "overloaded function" \
                           # N: Revealed type is "Any"
    y = x()
    reveal_type(y.delete)  # E: Invalid self argument "type[A[list[int]]]" to class attribute function "delete" with type "Callable[[type[A[int]], int], int]" \
                           # N: Revealed type is "Any"

[case overload_star_args_as_self_works]
from typing import Any, overload
class C:
    @overload
    def bar(self, x: C, /) -> None: ...
    @overload
    def bar(self, /) -> None: ...
    def bar(*args: C) -> None: ...

[case overload_class_type_vars_properly_applied_in_implementation_check]
from typing import Generic, overload, TypeVar

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
class MyClass(Generic[T1, T2]):
    @overload
    def __init__(self: MyClass[None, None], t: None, u: None) -> None: ...

    @overload
    def __init__(self: MyClass[T1, None], t: T1, u: None) -> None: ...

    @overload
    def __init__(self: MyClass[T1, T3], t: T1, u: T2) -> None: ...

    def __init__(self, t: T1, u: T2) -> None:  # E: Overloaded function implementation does not accept all possible arguments of signature 3
        pass

[case function_overlapping_kwonly_vs_normal]
[file foo.pyi]
from typing import overload

@overload
def g(*, x: int) -> str: pass
@overload
def g(x: int) -> int: pass

@overload
def h(x: int) -> int: pass
@overload
def h(*, x: int) -> str: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

[case part_of_overload_target]
# This used to fail because the parser has a primary_t
from typing import overload

class A:
    x: int
@overload
def g(x: str) -> A: pass
@overload
def g(x: int) -> A: pass
def g(x: object) -> object: ...

g(1).x = 1

[case overload_union_math_with_any_involved]
from typing import Any
from foo import foo

def x(x: int | str, y: list[Any]) -> None:
    reveal_type(foo(x, y))  # N: Revealed type is "int | bytes"

[file foo.pyi]
from typing import overload, Any

@overload
def foo(x: int, y: list[int]) -> int: ...
@overload
def foo(x: str, y: list[bytes]) -> bytes: ...
@overload
def foo(x: str, y: set[str]) -> str: ...

[case match_callable_against_overload_backtracking]
from typing import overload, Any, Callable, TypeVar

T = TypeVar("T")

@overload
def foo(x: int, y: int) -> int: ...
@overload
def foo(x: str, y: str) -> str: ...
def foo(x: object, y: object) -> Any: ...

def x(c: Callable[[T, str], T]) -> T: ...

reveal_type(x(foo))  # N: Revealed type is "str"

[case overload_overwrite]
import os
import posixpath

if bool():
    join = os.path.join
else:
    join = posixpath.join

[case overload_class_access_with_self]
from typing import TypeVar
T = TypeVar("T")
import foo
def f(x: T) -> T: ...

class Bar(foo.Foo): ...

as_var = f(foo.Foo.f)
reveal_type(as_var(foo.Foo(), 1))  # N: Revealed type is "foo.Foo"
reveal_type(as_var(Bar(), 1))  # N: Revealed type is "__main__.Bar"
reveal_type(as_var(foo.Foo(), ""))  # N: Revealed type is "None"

c = f(foo.Foo.c)
reveal_type(c(foo.Foo(), 1))  # N: Revealed type is "foo.Foo"
reveal_type(c(Bar(), 1))  # N: Revealed type is "__main__.Bar"

[file foo.pyi]
from typing import overload, Self, Callable, ClassVar
class Foo:
    @overload
    def f(self, x: int) -> Self: ...
    @overload
    def f(self, y: str) -> None: ...

    c: ClassVar[Callable[[Self, int], Self]]

[case overload_with_type_union_math]
from typing import overload

@overload
def foo(x: type[int]) -> int: ...
@overload
def foo(x: type[str]) -> str: ...
def foo(y): ...

def f(x: type[int | str], y: type[int] | type[str]) -> None:
    reveal_type(foo(x))  # N: Revealed type is "int | str"
    reveal_type(foo(y))  # N: Revealed type is "int | str"

[case invalid_overloads_mypy_compatible]
# flags: --mypy-compatible
from typing import overload

def non_callable(func) -> int: ...

@overload  # E: An overloaded function outside a stub file must have an implementation
def foo(x: int) -> int: ...
@overload
def foo(x: str) -> str: ...
foo = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "overloaded function")

@overload  # E: "int" not callable
@non_callable
def bar(x: int) -> int: ...
@overload
def bar(x: str) -> str: ...
def bar(x: object) -> object: ...

@overload  # E: "int" not callable
@non_callable
def baz(x: int) -> int: ...
@overload  # E: "int" not callable
@non_callable
def baz(x: str) -> str: ...
def baz(x: object) -> object: ...

[case invalid_overloads_no_mypy_compatible]
# flags: --no-mypy-compatible
from typing import overload

def non_callable(func) -> int: ...

@overload
def foo(x: int) -> int: ...  # E: An overloaded function outside a stub file must have an implementation
@overload
def foo(x: str) -> str: ...
foo = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "overloaded function")

@overload  # E: "int" not callable
@non_callable
def bar(x: int) -> int: ...
@overload
def bar(x: str) -> str: ...
def bar(x: object) -> object: ...

@overload  # E: "int" not callable
@non_callable
def baz(x: int) -> int: ...
@overload  # E: "int" not callable
@non_callable
def baz(x: str) -> str: ...
def baz(x: object) -> object: ...

[case invalid_comprehension_arg]
from typing import overload, Any

@overload
def foo(x: int) -> int: ...
@overload
def foo(x: str) -> str: ...
def foo(x): ...

foo(a for a in [1])  # E: No overload variant of "foo" matches argument type "Generator[int, None, None]" \
                     # N: Possible overload variants: \
                     # N:     def foo(x: int) -> int \
                     # N:     def foo(x: str) -> str

[case union_math_avoid_blowups]
from typing import Literal, overload
Literals1 = Literal["a", "b", "c", "d", "e", "f"]
Literals2 = Literal[0, 1, 2, 3, 4, 5]
TS = int | str | bytes | None | list | set

@overload
def func(
    a: Literals1 | None,
    b: Literals1,
    *,
    c: Literal[1],
    d: Literals2,
    e: TS,
    f: TS,
    g: TS,
    h: Literal[1],
) -> None: ...
@overload
def func(
    a: Literals1 | None,
    b: Literals1,
    *,
    c: int,
    d: Literals2,
    e: TS,
    f: TS,
    g: TS,
    h: Literal[1],
) -> None: ...
def func(*args, **kwargs) -> None: ...

def g(
    a: Literals1 | None,
    b: Literals1,
    c: Literals2,
    d: Literals2,
    e: TS,
    f: TS,
    g: TS,
    h: TS,
):
    return func(a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h)

[out]
__main__:42: error: Not all union combinations were tried because there are too many unions
__main__:42: error: No overload variant of "func" matches argument types "a=Literal['a', 'b', 'c', 'd', 'e', 'f'] | None", "b=Literal['a', 'b', 'c', 'd', 'e', 'f']", "c=Literal[0, 1, 2, 3, 4, 5]", "d=Literal[0, 1, 2, 3, 4, 5]", "e=int | str | bytes | None | list[Any] | set[Any]", "f=int | str | bytes | None | list[Any] | set[Any]", "g=int | str | bytes | None | list[Any] | set[Any]", "h=int | str | bytes | None | list[Any] | set[Any]"
__main__:42: note: Possible overload variants:
__main__:42: note:     def func(a: Literal['a', 'b', 'c', 'd', 'e', 'f'] | None, b: Literal['a', 'b', 'c', 'd', 'e', 'f'], *, c: Literal[1], d: Literal[0, 1, 2, 3, 4, 5], e: int | str | bytes | None | list[Any] | set[Any], f: int | str | bytes | None | list[Any] | set[Any], g: int | str | bytes | None | list[Any] | set[Any], h: Literal[1]) -> None
__main__:42: note:     def func(a: Literal['a', 'b', 'c', 'd', 'e', 'f'] | None, b: Literal['a', 'b', 'c', 'd', 'e', 'f'], *, c: int, d: Literal[0, 1, 2, 3, 4, 5], e: int | str | bytes | None | list[Any] | set[Any], f: int | str | bytes | None | list[Any] | set[Any], g: int | str | bytes | None | list[Any] | set[Any], h: Literal[1]) -> None

[case overload_with_empty_unpack]
from typing import overload, Unpack, TypedDict

class EmptyKwargs(TypedDict): ...
class NotEmptyKwargs(TypedDict):
    something: int

@overload
def f(x: int) -> int: ...
@overload
def f(*, alias: str, **extra: Unpack[EmptyKwargs]) -> int: ...
def f(*args, **kwargs): ...

f(alias="asdf")

@overload
def g(x: int) -> int: ...
@overload
def g(*, alias: str, **extra: Unpack[NotEmptyKwargs]) -> int: ...
def g(*args, **kwargs): ...

g(alias="")  # E: No overload variant of "g" matches argument type "alias=str" \
             # N: Possible overload variants: \
             # N:     def g(x: int) -> int \
             # N:     def g(*, alias: str, **extra: Unpack[NotEmptyKwargs]) -> int


def f2(*, alias: str, **extra: Unpack[EmptyKwargs]) -> int: ...
f2(alias="")
f2(alias=1) # E: Argument "alias" to "f2" has incompatible type "int"; expected "str"

def g2(*, alias: str, **extra: Unpack[NotEmptyKwargs]) -> int: ...

g2(alias="") # E: Missing named argument "something" for "g2"

[case overload_with_getitem_and_issue_should_report]
from typing import overload

class D[T]:
    @overload
    def __getitem__(self, x: int) -> int: ...
    @overload
    def __getitem__(self, x: slice) -> str: ...
    def __getitem__(self, x): ...

D()[1()]  # E: "int" not callable
D()[1]
D()[1():]  # E: "int" not callable
D()[1:]

[case overload_self_in_impl_and_items]
from typing import Self, overload

class C:
    @overload
    def a1(self, other: Self) -> bool: ...
    @overload
    def a1(self, other: int) -> bool: ...
    def a1(self, other: C | int) -> bool: ...

    @overload
    def a2(self, other: Self) -> Self: ...
    @overload
    def a2(self, other: int) -> Self: ...
    def a2(self, other: C | int) -> Self: ...

    @overload
    def a3(self, other: Self) -> Self: ...
    @overload
    def a3(self, other: int) -> Self: ...
    def a3(self, other: Self | int) -> Self: ...

    @overload
    def a4(self, other: C) -> bool: ...
    @overload
    def a4(self, other: int) -> bool: ...
    def a4(self, other: Self | int) -> bool: ...

    @overload
    def a5(self, other: C) -> Self: ...
    @overload
    def a5(self, other: int) -> Self: ...
    def a5(self, other: Self | int) -> Self: ...

    @overload
    def a6(self, other: C) -> Self: ...
    @overload
    def a6(self, other: int) -> Self: ...
    def a6(self, other: C | int) -> Self: ...

[case overload_checking_should_halt]
# This piece of code used to loop
from typing import overload

@overload
def f(*, x: int) -> int: ...
@overload
def f(x: str, /) -> str: ...
def f(x = None, /, **kwargs) -> int | str: ...

[case overload_dunder_should_not_have_an_issue]
# Copied from conformance tests (overloads_basic.py)
from typing import overload
class Bytes:
    @overload
    def __getitem__(self, __i: int) -> int: ...
    @overload
    def __getitem__(self, __s: slice) -> bytes: ...
    def __getitem__(self, __i_or_s: int | slice) -> int | bytes:
        if isinstance(__i_or_s, int):
            return 0
        else:
            return b""

[case overload_function_only_one_positions]
# flags: --show-column-numbers --show-error-end
from typing import overload
@overload
def func1() -> None:
    ...

@overload
def func2() -> None: ...

x = 1

[out]
__main__:3:1:5:8: error: Single overload definition, multiple required
__main__:7:1:8:25: error: Single overload definition, multiple required

[case overload_inconsistent_staticmethod]
from m import C

C().func("")  # E: Argument 1 to "func" of "C" has incompatible type "str"; expected "int"
C().func(1)
C.func("")
C.func(1) # E: No overload variant of "func" of "C" matches argument type "int" \
          # N: Possible overload variants: \
          # N:     def func(self, int, /) -> int \
          # N:     def func(str, /) -> str


[file m.pyi]
from typing import overload
class C:
    @overload  # E: Overload does not consistently use the "@staticmethod" decorator on all function signatures.
    def func(self, x: int, /) -> int:
        ...
    @overload
    @staticmethod
    def func(x: str, /) -> str:
        ...

[case overload_incorrect_final_positions]
# flags: --show-column-numbers --show-error-end
from typing import overload, final
class C:
    @overload
    @final
    def func(self) -> None: ...
    @overload
    def func(self, x: int) -> None: ...
    def func(self, x: int | None = None) -> None: ...

[out]
__main__:5:5:5:11: error: @final should be applied only to overload implementation

[case overload_override_in_correct_positions]
# flags: --no-mypy-compatible
from typing import overload, override, final
class C:
    def to_override(self, x: int) -> int: ...

class D(C):
    @overload
    def to_override(self, x: int) -> int: ...
    @overload
    @override  # E: @override should be applied only to overload implementation
    def to_override(
        self, x: str
    ) -> str:
        ...
    @override
    def to_override(self, x: int | str) -> int | str: ...

[file m.pyi]
from typing import overload, override
class E:
    def to_override(self, x: int) -> int: ...

class F(E):
    @overload
    def to_override(self, x: int) -> int: ...
    @overload
    @override  # E: In a stub file @override must be applied only to the first overload
    def to_override(
        self, x: str
    ) -> str:
        ...

[case reverted_testTypeIsInOverloads]
# flags: --mypy-compatible
# From https://github.com/python/mypy/pull/17678 and were reverted
from typing import Any, overload, Union
from typing_extensions import TypeIs

@overload
def func1(x: str) -> TypeIs[str]:
    ...

@overload
def func1(x: int) -> TypeIs[int]:
    ...

def func1(x: Any) -> Any:
    return True

def func2(val: Any):
    if func1(val):
--zuban-diff         reveal_type(val)  # N: Revealed type is "Union[builtins.str, builtins.int]"
        reveal_type(val)  # N: Revealed type is "Any"
    else:
        reveal_type(val)  # N: Revealed type is "Any"

def func3(val: Union[int, str]):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int | str"
    else:
        reveal_type(val)

def func4(val: int):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int"
    else:
        reveal_type(val)
[builtins fixtures/tuple.pyi]

[case reverted_testTypeIsInOverloadsSameReturn]
# From https://github.com/python/mypy/pull/17678 and was reverted, but still useful
from typing import Any, overload, Union
from typing_extensions import TypeIs

@overload
def func1(x: str) -> TypeIs[str]:
    ...

@overload
def func1(x: int) -> TypeIs[str]:  # type: ignore
    ...

def func1(x: Any) -> Any:
    return True

def func2(val: Union[int, str]):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "str"
    else:
        reveal_type(val)  # N: Revealed type is "int"
[builtins fixtures/tuple.pyi]

[case reverted_testTypeIsInOverloadsUnionizeError]
# From https://github.com/python/mypy/pull/17678 and was reverted, but still useful
from typing import Any, overload, Union
from typing_extensions import TypeIs, TypeGuard

@overload
def func1(x: str) -> TypeIs[str]:
    ...

@overload
def func1(x: int) -> TypeGuard[int]:
    ...

def func1(x: Any) -> Any:
    return True

def func2(val: Union[int, str]):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int | str"
    else:
        reveal_type(val)  # N: Revealed type is "int | str"
[builtins fixtures/tuple.pyi]

[case reverted_testTypeIsInOverloadsUnionizeError2]
# From https://github.com/python/mypy/pull/17678 and was reverted, but still useful
from typing import Any, overload, Union
from typing_extensions import TypeIs, TypeGuard

@overload
def func1(x: int) -> TypeGuard[int]:
    ...

@overload
def func1(x: str) -> TypeIs[str]:
    ...

def func1(x: Any) -> Any:
    return True

def func2(val: Union[int, str]):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int | str"
    else:
        reveal_type(val)  # N: Revealed type is "int | str"
[builtins fixtures/tuple.pyi]

[case reverted_testTypeIsLikeIsDataclass]
# From https://github.com/python/mypy/pull/17678 and was reverted, but still useful
from typing import Any, overload, Union, Type
from typing_extensions import TypeIs

class DataclassInstance: ...

@overload
def is_dataclass(obj: type) -> TypeIs[Type[DataclassInstance]]: ...
@overload
def is_dataclass(obj: object) -> TypeIs[Union[DataclassInstance, Type[DataclassInstance]]]: ...

def is_dataclass(obj: Union[type, object]) -> bool:
    return False

def func(arg: Any) -> None:
    if is_dataclass(arg):
--zuban-diff         reveal_type(arg)  # N: Revealed type is "Union[type[__main__.DataclassInstance], __main__.DataclassInstance]"
        reveal_type(arg)  # N: Revealed type is "Any"
[builtins fixtures/tuple.pyi]

[case reverted_testNoCrashOnDunderCallTypeGuardTemporaryObject]
# From https://github.com/python/mypy/pull/17678 and was reverted, but still useful
from typing_extensions import TypeGuard, overload, Any, Union

@overload
def func1(x: str) -> TypeGuard[str]:
    ...

@overload
def func1(x: int) -> TypeGuard[int]:
    ...

def func1(x: Any) -> Any:
    return True

def func2(val: Any):
    if func1(val):
--zuban-diff         reveal_type(val)  # N: Revealed type is "Union[builtins.str, builtins.int]"
        reveal_type(val)  # N: Revealed type is "Any"
    else:
        reveal_type(val)  # N: Revealed type is "Any"

def func3(val: Union[int, str]):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int | str"
    else:
        reveal_type(val)  # N: Revealed type is "int | str"

def func4(val: int):
    if func1(val):
        reveal_type(val)  # N: Revealed type is "int"
    else:
        reveal_type(val)  # N: Revealed type is "int"
