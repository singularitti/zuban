[case new_type_wrong_arguments]
from typing import NewType

X = NewType("X", float)

X() # E: Too few arguments for "X"
X(1.0)
X(1)
X("") # E: Argument 1 to "X" has incompatible type "str"; expected "float"
X(1.0, 2.0) # E: Too many arguments for "X"

[case new_type_with_class_generics]
from typing import NewType, TypeVar, Generic

T = TypeVar("T")

class Y(Generic[T]):
    X = NewType("X", list[T])

    def __init__(self, x: T):
        self.self_t = x
        reveal_type(Y.X([x])) # N: Revealed type is "__main__.X"
        reveal_type(Y.X(1)) # N: Revealed type is "__main__.X" \
                            # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]"

reveal_type(Y.X)  # N: Revealed type is "type[__main__.X]"
Y.X(1) # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]"
Y.X([1]) # E: List item 0 has incompatible type "int"; expected "T"
Y[int].X([1]) # E: List item 0 has incompatible type "int"; expected "T"
Y(1).self_t

[case new_type_with_class_generics2]
# This is like new_type_with_class_generics, but there were issues with the
# execution order, so we added additional tests to ensure this won't be an
# issue in the future.
from typing import NewType, TypeVar, Generic

T = TypeVar("T")

class Y(Generic[T]):
    X = NewType("X", list[T])

reveal_type(Y.X)  # N: Revealed type is "type[__main__.X]"
Y.X(1) # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]"
Y.X([1]) # E: List item 0 has incompatible type "int"; expected "T"
Y[int].X([1]) # E: List item 0 has incompatible type "int"; expected "T"

[case new_type_with_class_generics3]
from typing import NewType, TypeVar, Generic

T = TypeVar("T")

class Y(Generic[T]):
    X = NewType("X", list[T])

    def __init__(self, x: T):
        self.self_t = x
        reveal_type(Y.X([x])) # N: Revealed type is "__main__.X"
        reveal_type(Y.X(1)) # N: Revealed type is "__main__.X" \
                            # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]"

Y(1).self_t
reveal_type(Y.X)  # N: Revealed type is "type[__main__.X]"
Y.X(1) # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]"
Y.X([1]) # E: List item 0 has incompatible type "int"; expected "T"
Y[int].X([1]) # E: List item 0 has incompatible type "int"; expected "T"

[case new_type_with_function_generics]
from typing import NewType, TypeVar

T = TypeVar("T")

def y(a: T) -> T:
    X = NewType("X", list[T])

    reveal_type(X)  # N: Revealed type is "type[__main__.X]"
    reveal_type(X(1)) # E: Argument 1 to "X" has incompatible type "int"; expected "list[T]" \
                      # N: Revealed type is "__main__.X"
    reveal_type(X([a]))  # N: Revealed type is "__main__.X"
    return a

[case new_type_type_initialization]
from typing import NewType
class Foo:
    def __init__(self, x: int) -> None: ...
X = NewType("X", Foo)

def f(a: type[X]) -> None:
    x1: X = a()  # E: Too few arguments for "X"
    x2: X = a(1)  # E: Argument 1 to "X" has incompatible type "int"; expected "Foo"
    x3: X = a(1, 2)  # E: Too many arguments for "X"
    x4: X = a(Foo(1))

[case new_type_invalid_params]
from typing import NewType, TypeVarTuple
Ts = TypeVarTuple("Ts")

N = NewType("N", int)
N(1)
N(a=1)  # E: NewTypes expect a single positional argument
N(*[1])  # E: NewTypes expect a single positional argument

def unpack(x: tuple[*Ts]):
    N(*x)  # E: NewTypes expect a single positional argument

[case new_type_is_no_type]
# From conformance tests (aliases_newtype.py) and slightly extended
from typing import NewType, Any, Type
UserId = NewType("UserId", int)
reveal_type(UserId)  # N: Revealed type is "type[__main__.UserId]"
_: type = UserId  # E: Incompatible types in assignment (expression has type "type[UserId]", variable has type "type[Any]")

a: Type[Any] = UserId  # E: Incompatible types in assignment (expression has type "type[UserId]", variable has type "type[Any]")
b: Type[UserId] = UserId  # E: Incompatible types in assignment (expression has type "type[UserId]", variable has type "type[UserId]")
