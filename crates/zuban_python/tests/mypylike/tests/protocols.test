[case protocol_class_access_with_self_type_check_without_ignoring_params_names]
-- From testProtocolTypeTypeSelfTypeInstanceMethod
from typing import Protocol, Type, TypeVar, Union

T = TypeVar("T")
class P(Protocol):
    def foo(ob, self: T) -> T: ...

class B:
    def foo(self: T) -> T: ...
class C:
    def foo(self: T) -> Union[T, int]: ...

def test(arg: P) -> None: ...
b: Type[B]
c: Type[C]
test(b)  # OK
test(c)  # E: Argument 1 to "test" has incompatible type "type[C]"; expected "P" \
         # N: Following member(s) of "C" have conflicts: \
         # N:     Expected: \
         # N:         def [T] foo(self: T) -> T \
         # N:     Got: \
         # N:         def [T] foo(self: T) -> Union[T, int]

[case protocol_with_ellipsis_default]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: int = ...) -> None: ...

[case protocol_class_object_callable_possible]
-- testProtocolClassObjectCallableError a bit modified
from typing import Protocol, Any, Callable

class P(Protocol):
    def __call__(self, app: int) -> Callable[[str], None]:
        ...

class Q(Protocol):
    def __call__(self, app: str) -> Callable[[str], None]:
        ...

class R(Protocol):
    def __call__(self, app: str) -> Callable[[int], None]:
        ...

class C:
    def __init__(self, app: str) -> None:
        pass

    def __call__(self, el: str) -> None:
        return None

p: P = C  # E: Incompatible types in assignment (expression has type "type[C]", variable has type "P") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "P" \
          # N:     Expected: \
          # N:         def __call__(app: int) -> Callable[[str], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C
q: Q = C
r: R = C  # E: Incompatible types in assignment (expression has type "type[C]", variable has type "R") \
          # N: Following member(s) of "C" have conflicts: \
          # N: "C" has constructor incompatible with "__call__" of "R" \
          # N:     Expected: \
          # N:         def __call__(app: str) -> Callable[[int], None] \
          # N:     Got: \
          # N:         def __init__(app: str) -> C

[case supports_keys_and_getitem_propagation]
from typing import TypeVar, Tuple
from _typeshed import SupportsKeysAndGetItem

S = TypeVar('S')
T = TypeVar('T')
def foo(x: SupportsKeysAndGetItem[S, T]) -> Tuple[S, T]: ...

x: Tuple[int, str] = foo(reveal_type({}))  # N: Revealed type is "dict[int, str]"

[case iterable_propagation]
from typing import TypeVar, Tuple, Iterable

T = TypeVar('T')

def foo(x: Iterable[T]) -> T: ...
def bar(x: Iterable[T]) -> Tuple[T]: ...

x: int = foo(reveal_type([]))  # N: Revealed type is "list[int]"
y: Tuple[int] = bar(reveal_type([]))  # N: Revealed type is "list[int]"

[case join_protocol_both_sides]
# Like testJoinProtocolWithProtocol, but with additional tests
from typing import Protocol

class P(Protocol):
    attr: int
class P2(Protocol):
    attr: int
    attr2: str

x: P
y: P2

l0 = [x, x]
l1 = [y, y]
l = [x, y]
k = [y, x]
reveal_type(l0) # N: Revealed type is "list[__main__.P]"
reveal_type(l1) # N: Revealed type is "list[__main__.P2]"
reveal_type(l) # N: Revealed type is "list[__main__.P]"
reveal_type(k) # N: Revealed type is "list[__main__.P]"

[case protocol_recursive]
from typing import Protocol
class Foo(Protocol):
    def foo(self) -> Foo: ...

class GoodImpl1:
    def foo(self) -> GoodImpl1: return self
class GoodImpl2:
    def foo(self) -> GoodImpl1: raise NotImplementedError
class BadImpl1:
    def foo(self) -> str: return ''
class BadImpl2:
    def foo(self) -> BadImpl1: raise NotImplementedError

def check(x: Foo) -> None: ...
check(GoodImpl1())
check(GoodImpl2())
check(BadImpl1())
check(BadImpl2())

[out]
__main__:17: error: Argument 1 to "check" has incompatible type "BadImpl1"; expected "Foo"
__main__:17: note: Following member(s) of "BadImpl1" have conflicts:
__main__:17: note:     Expected:
__main__:17: note:         def foo(self) -> Foo
__main__:17: note:     Got:
__main__:17: note:         def foo(self) -> str
__main__:18: error: Argument 1 to "check" has incompatible type "BadImpl2"; expected "Foo"
__main__:18: note: Following member(s) of "BadImpl2" have conflicts:
__main__:18: note:     Expected:
__main__:18: note:         def foo(self) -> Foo
__main__:18: note:     Got:
__main__:18: note:         def foo(self) -> BadImpl1

[case protocol_recursive_with_param]
from typing import Protocol
class Foo(Protocol):
    def foo(self, x: Foo) -> Foo: ...

class GoodImpl1:
    def foo(self, x: GoodImpl1) -> GoodImpl1: return self
class GoodImpl2:
    def foo(self, x: GoodImpl2) -> GoodImpl1: raise NotImplementedError
class BadImpl1:
    def foo(self, x: BadImpl1) -> str: return ''
class BadImpl2:
    def foo(self, x: BadImpl2) -> BadImpl1: raise NotImplementedError

def check(x: Foo) -> None: ...
check(GoodImpl1())
check(GoodImpl2())
check(BadImpl1())
check(BadImpl2())

[out]
__main__:15: error: Argument 1 to "check" has incompatible type "GoodImpl1"; expected "Foo"
__main__:15: note: Following member(s) of "GoodImpl1" have conflicts:
__main__:15: note:     Expected:
__main__:15: note:         def foo(self, x: Foo) -> Foo
__main__:15: note:     Got:
__main__:15: note:         def foo(self, x: GoodImpl1) -> GoodImpl1
__main__:16: error: Argument 1 to "check" has incompatible type "GoodImpl2"; expected "Foo"
__main__:16: note: Following member(s) of "GoodImpl2" have conflicts:
__main__:16: note:     Expected:
__main__:16: note:         def foo(self, x: Foo) -> Foo
__main__:16: note:     Got:
__main__:16: note:         def foo(self, x: GoodImpl2) -> GoodImpl1
__main__:17: error: Argument 1 to "check" has incompatible type "BadImpl1"; expected "Foo"
__main__:17: note: Following member(s) of "BadImpl1" have conflicts:
__main__:17: note:     Expected:
__main__:17: note:         def foo(self, x: Foo) -> Foo
__main__:17: note:     Got:
__main__:17: note:         def foo(self, x: BadImpl1) -> str
__main__:18: error: Argument 1 to "check" has incompatible type "BadImpl2"; expected "Foo"
__main__:18: note: Following member(s) of "BadImpl2" have conflicts:
__main__:18: note:     Expected:
__main__:18: note:         def foo(self, x: Foo) -> Foo
__main__:18: note:     Got:
__main__:18: note:         def foo(self, x: BadImpl2) -> BadImpl1

[case protocol_contravariant]
from typing import Protocol

class X(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
    def o(self) -> None: ...
class P(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
class Q(Protocol):
    def m(self) -> None: ...

class Bar:
    def foo(self, other: P) -> None: ...
    def bar(self, other: P) -> None: ...
class Baz(Bar):
    def foo(self, other: Q) -> None: ...
    def bar(self, other: X) -> None: ...  # E: Argument 1 of "bar" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

[case protocol_contravariant_against_class]
from typing import Protocol

class X():
    def m(self) -> None: ...
    def n(self) -> None: ...
    def o(self) -> None: ...
class P(Protocol):
    def m(self) -> None: ...
    def n(self) -> None: ...
class Q():
    def m(self) -> None: ...

class Bar:
    def foo(self, other: P) -> None: ...
    def bar(self, other: P) -> None: ...
class Baz(Bar):
    def foo(self, other: Q) -> None: ...  # E: Argument 1 of "foo" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    def bar(self, other: X) -> None: ...  # E: Argument 1 of "bar" is incompatible with supertype "Bar"; supertype defines the argument type as "P" \
                                          # N: This violates the Liskov substitution principle \
                                          # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides

[case protocol_match_avoid_exponential_blowup]
# This was an issue in PyTorch, where this code takes extremely long to
# typecheck, because of an exponential blowup.
from typing import Protocol, Union, TypeVar, Iterator

T_co = TypeVar("T_co", covariant=True)

class NestedSequence(Protocol[T_co]):
    def __getitem__(self, index: int) -> T_co | NestedSequence[T_co]: ...
    # Every additional method here doubled the time it takes to finish
    def x_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...
    def y_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...
    def z_method(self) -> Iterator[T_co | NestedSequence[T_co]]: ...

class Base:
    def __getitem__(self, indices: NestedSequence[Base | None]) -> Base: ...

def foo(x: Base) -> None:
    x[::1, ::2]  # E: Invalid index type "tuple[slice[None, None, int], slice[None, None, int]]" for "Base"; expected type "NestedSequence[Base | None]"

[case protocol_self_types_on_both_sides]
from typing import Protocol, TypeVar, Generic
T = TypeVar('T')
class Proto(Protocol):
    def foo(self) -> int: ...
    def bar(self) -> str: ...

class Foo(Generic[T]):
    def foo(self: Foo[int]) -> T: ...
    def bar(self) -> str: ...

class Bar(Generic[T]):
    def foo(self: Bar[str]) -> T: ...
    def bar(self) -> str: ...

def check(foo: Foo[int], foo2: Foo[str], bar: Bar[int], bar2: Bar[str]) -> Proto:
    if bool():
        return foo
    elif bool():
        return foo2 # E: Incompatible return value type (got "Foo[str]", expected "Proto") \
                    # N: Invalid self argument "Foo[str]" to attribute function "foo" with type "Callable[[Foo[int]], T]"
    elif bool():
        return bar # E: Incompatible return value type (got "Bar[int]", expected "Proto") \
                   # N: Invalid self argument "Bar[int]" to attribute function "foo" with type "Callable[[Bar[str]], T]"
    else:
        return bar2 # E: Incompatible return value type (got "Bar[str]", expected "Proto") \
                    # N: Following member(s) of "Bar[str]" have conflicts: \
                    # N:     Expected: \
                    # N:         def foo(self: Proto) -> int \
                    # N:     Got: \
                    # N:         def foo(self: Bar[str]) -> str

[case protocols_concrete_vs_abstract_subtyping]
# Copied from conformance tests (protocols_class_objects.py)
# > Variables and parameters annotated with Type[Proto] accept only concrete
# (non-protocol) subtypes of Proto.

from abc import abstractmethod
from typing import Any, ClassVar, Protocol

class Proto(Protocol):
    @abstractmethod
    def meth(self) -> int: ...

class Concrete:
    def meth(self) -> int:
        return 42

def fun(cls: type[Proto]) -> int:
    return cls().meth()  # OK

fun(Proto)  # E: Only concrete class can be given where "type[Proto]" is expected
fun(Concrete)  # OK

var: type[Proto]
var = Proto  # E: Can only assign concrete classes to a variable of type "type[Proto]"
var = Concrete  # OK
var().meth()  # OK

[case protocols_frozen_dataclass_assignment]
# Copied from conformance tests (protocols_definition.py)
from typing import Protocol, Sequence
from dataclasses import dataclass
class Template6(Protocol):
    @property
    def val1(self) -> Sequence[float]:
        ...

    @val1.setter
    def val1(self, val: Sequence[float]) -> None:
        ...

@dataclass(frozen=False)
class Concrete6_Good3:
    val1: Sequence[float] = [0]

@dataclass(frozen=True)
class Concrete6_Bad3:
    val1: Sequence[float] = [0]


v6_good3: Template6 = Concrete6_Good3()  # OK
v6_bad3: Template6 = Concrete6_Bad3()  # E: Incompatible types in assignment (expression has type "Concrete6_Bad3", variable has type "Template6") \
                                       # N: Protocol member Template6.val1 expected settable variable, got read-only attribute

[case protocols_runtime_checkable_issubclass]
# Copied from conformance tests (protocols_runtime_checkable.py)
from typing import Protocol, runtime_checkable, Any
@runtime_checkable
class DataProtocol(Protocol):
    name: str

    def method1(self) -> int:
        ...

@runtime_checkable
class NonDataProtocol(Protocol):
    def method1(self) -> int:
        ...

def func2(a: Any):
    if issubclass(a, (NonDataProtocol, DataProtocol)):  # E: Only protocols that don't have non-method members can be used with issubclass() \
                                                        # N: Protocol "DataProtocol" has non-method member(s): name
        return

[case protocols_not_instantiated]
# Copied from conformance tests (protocols_explicit.py)
from abc import ABC, abstractmethod
from typing import ClassVar, Protocol

class PColor(Protocol):
    @abstractmethod
    def draw(self) -> str:
        ...

    def complex_method(self) -> int:
        return 1

class NiceColor(PColor):
    def draw(self) -> str:
        return "deep blue"

class BadColor(PColor):
    def draw(self) -> str:
        return super().draw()  # E: Call to abstract method "draw" of "PColor" with trivial body via super() is unsafe

v1: PColor = NiceColor()

[case protocol_assign_to_classvar]
# Copied from conformance tests (protocols_explicit.py)
from typing import ClassVar, Protocol
class Proto1(Protocol):
    cm1: ClassVar[int]
    cm2: ClassVar[int] = 0

    im1: int
    im2: int = 2
    im3: int

    def __init__(self):
        self.im3 = 3


class Proto2(Protocol):
    cm10: int


class Proto3(Proto2, Protocol):
    cm11: int


class Concrete1(Proto1):
    def __init__(self) -> None:
        self.cm1 = 1
        self.im1 = 1
        self.im3 = 3

[case protocol_callable_matching_precise_types]
# flags: --allow-redefinition
from typing import Any, Callable, ParamSpec, Protocol, TypeVar, cast, overload

class Proto1(Protocol):
    def __call__(self, *vals: bytes, max_len: int | None = None) -> list[bytes]:
        ...

def cb1_good1(*vals: bytes, max_len: int | None = None) -> list[bytes]:
    return []

def cb1_bad1(*vals: bytes, max_items: int | None) -> list[bytes]:
    return []

def cb1_bad2(*vals: bytes) -> list[bytes]:
    return []

def cb1_bad3(*vals: bytes, max_len: str | None) -> list[bytes]:
    return []

cb1: Proto1 = cb1_good1  # OK
cb1 = cb1_bad1  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes), NamedArg(int | None, 'max_items')], list[bytes]]", variable has type "Proto1")
cb1 = cb1_bad2  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes)], list[bytes]]", variable has type "Proto1")
cb1 = cb1_bad3  # E: Incompatible types in assignment (expression has type "Callable[[VarArg(bytes), NamedArg(str | None, 'max_len')], list[bytes]]", variable has type "Proto1")
