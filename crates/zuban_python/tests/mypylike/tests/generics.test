-- Generally cases that were forgotten in Mypy

-- Generics base classes
-- ---------------------

[case single_generic]
from typing import TypeVar, Generic, Protocol
T = TypeVar('T')
S = TypeVar('S')
U = TypeVar('U')

class P1(Generic[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    pass

class P2(Generic[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P3(Protocol[T], Generic[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P4(Protocol[T], Protocol[S]): # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T

class P5(Generic[T], Generic[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T
    z: U

class P6(Generic[T], Protocol[S], Protocol[U]): # E: Only single Generic[...] or Protocol[...] can be in bases # E: Only single Generic[...] or Protocol[...] can be in bases
    x: S
    y: T
    z: U

[out]

[case type_type_application]
from typing import Type
reveal_type(Type[int]) # N: Revealed type is "typing._SpecialForm"

[case subtyping_only_result_generics]
# flags: --disallow-redefinition
-- It feels like this test is a bit weird, because a generic as a result in
-- Python doesn't really make sense.
from typing import TypeVar
class A: pass
T = TypeVar('T', int, str)
U = TypeVar('U', str, A, int)
def f(x: int) -> T: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
def g(x: int) -> U: pass # E: A function returning TypeVar should receive at least one argument containing the same Typevar
a = f
if int():
    a = f
if int():
    a = g
b = g
if int():
    b = g
if int():
    b = f # E: Incompatible types in assignment (expression has type "Callable[[int], T]", variable has type "Callable[[int], U]")

[case subtyping_complex_generics]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
def f(x: T, y: int, /) -> T: pass
def g(x: T, y: U, /) -> U: pass
def h(x: U, y: U, /) -> U: pass
if int():
    f = f
if int():
    f = g # E: Incompatible types in assignment (expression has type "Callable[[T@g, U], U]", variable has type "Callable[[T@f, int], T@f]")
if int():
    f = h # E: Incompatible types in assignment (expression has type "Callable[[U, U], U]", variable has type "Callable[[T, int], T]")

if int():
    g = f # E: Incompatible types in assignment (expression has type "Callable[[T@f, int], T@f]", variable has type "Callable[[T@g, U], U]")
if int():
    g = g
if int():
    g = h # E: Incompatible types in assignment (expression has type "Callable[[U@h, U@h], U@h]", variable has type "Callable[[T, U@g], U@g]")

if int():
    h = f # E: Incompatible types in assignment (expression has type "Callable[[T, int], T]", variable has type "Callable[[U, U], U]")
if int():
    h = g
if int():
    h = h

[case unite_type_vars_mypy_issue_5874_join]
# flags: --use-joins
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)

[case unite_type_vars_mypy_issue_5874_no_join]
# flags: --no-use-joins
from typing import TypeVar, List, Union
T = TypeVar('T')
S = TypeVar('S')

def add(x: List[T], y: List[S]) -> List[Union[T, S]]: ...

a: List[int]
b: List[str]

e: List[Union[int, str]] = add(a, b)

[case init_type_var_on_self_issue_6520]
from typing import TypeVar, Generic

T = TypeVar('T')
class A:
    def __init__(self, x: T) -> None:
        self.x = x
    def get(self) -> T:  # E: A function returning TypeVar should receive at least one argument containing the same Typevar
        return self.x  # E: Incompatible return value type (got "T@__init__", expected "T@get")

x: int = A('lol').get()

[case nested_generic_mismatch_function]
from typing import TypeVar
T = TypeVar('T')

def add(x: list[T]) -> list[T]: ...

a: list[int] = add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = add([1])

[case nested_generic_mismatch_class]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: list[T]) -> list[T]: ...

a: list[int] = Foo[int]().add([""]) # E: List item 0 has incompatible type "str"; expected "int"
b: list[int] = Foo[int]().add([1])

[case nested_generic_mismatch_function_and_tuple]
from typing import TypeVar
T = TypeVar('T')

def add(x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = add(("",)) # E: Argument 1 to "add" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_class_and_tuple]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: tuple[T]) -> tuple[T]: ...

a: tuple[int] = Foo[int]().add(("",)) # E: Argument 1 to "add" of "Foo" has incompatible type "tuple[str]"; expected "tuple[int]"

[case nested_generic_mismatch_function_and_callable]
from typing import TypeVar, Callable
T = TypeVar('T')

def add(c: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[str], int | list[str]]
a: int = add(c) # E: Argument 1 to "add" has incompatible type "Callable[[str], int | list[str]]"; expected "Callable[[Never], Never | list[Never]]"

[case nested_generic_mismatch_class_and_callable]
from typing import TypeVar, Generic, Callable
T = TypeVar('T')

class Foo(Generic[T]):
    def add(self, x: Callable[[T], T | list[T]]) -> T: ...

c: Callable[[int], int | list[str]]
a: int = Foo[int]().add(c) # E: Argument 1 to "add" of "Foo" has incompatible type "Callable[[int], int | list[str]]"; expected "Callable[[int], int | list[int]]"

[case union_context_class_matching]
from typing import TypeVar, Generic
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

a: Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
b: Foo[str] = Foo("")

c: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | str = Foo("")

e: int | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
f: str | Foo[str] = Foo("")

[case union_context_class_matching_with_any]
from typing import TypeVar, Generic, Any
T = TypeVar('T')

class Foo(Generic[T]):
    def __init__(self, t: T): ...

c: Foo[int] | Any = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
d: Foo[str] | Any = Foo("")

e: Any | Foo[int] = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
f: Any | Foo[str] = Foo("")

[case union_context_class_matching_with_overload]
# flags: --mypy-compatible
from typing import TypeVar, Generic, overload
T = TypeVar('T')

class Foo(Generic[T]):
    @overload
    def __init__(self, t: list[T]): ...
    @overload
    def __init__(self, t: T): ...
    def __init__(self, t): ...

x: Foo[int] | int = Foo("") # E: Argument 1 to "Foo" has incompatible type "str"; expected "int"
y: Foo[str] | str = Foo("")

lst: list[str]
x = Foo(lst) # E: Argument 1 to "Foo" has incompatible type "list[str]"; expected "list[int]"
y = Foo(lst)

[case contravariant_type_var]
from typing import Generic, TypeVar

T = TypeVar('T')
T_contra = TypeVar('T_contra', contravariant=True)

class A(Generic[T_contra]): pass
class B(A[T]): pass

class C: ...
class D(C): ...

def f(x: A[T], y: A[T]) -> B[T]: ...
def g(x: A[T], y: A[T]) -> A[T]: ...

c: B[C]
d: B[D]
reveal_type(f(c, d)) # N: Revealed type is "__main__.B[__main__.D]"
reveal_type(f(d, c)) # N: Revealed type is "__main__.B[__main__.D]"
x1: A[C] = f(d, c) # E: Argument 1 to "f" has incompatible type "B[D]"; expected "A[C]"
x2: A[C] = f(c, d) # E: Argument 2 to "f" has incompatible type "B[D]"; expected "A[C]"
x3: A[D] = f(d, c)
x4: A[D] = f(c, d)

y1: A[C] = g(d, c) # E: Argument 1 to "g" has incompatible type "B[D]"; expected "A[C]"
y2: A[C] = g(c, d) # E: Argument 2 to "g" has incompatible type "B[D]"; expected "A[C]"
y3: A[D] = g(d, c)
y4: A[D] = g(c, d)

[case type_var_with_co_and_contra_abstract]
from typing import Generic, TypeVar

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): ...
class Contra(Generic[T_contra]): ...

class A: ...
class B(A): ...

def f(x: Co[T], y: Contra[T]) -> T: ...

a_co: Co[A]
b_co: Co[B]
a_contra: Contra[A]
b_contra: Contra[B]

f(a_co, a_contra)
f(b_co, b_contra)
f(a_co, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Contra[A]"
f(b_co, a_contra)

[case type_var_with_co_and_contra_real_life]
from typing import Generic, TypeVar, Iterable
from _typeshed import SupportsWrite

T = TypeVar('T')

class A: ...
class B(A): ...

def f(iterable: Iterable[T], writer: SupportsWrite[T]) -> None:
    for x in iterable:
        writer.write(x)

a_iterable: Iterable[A]
b_iterable: Iterable[B]
a_writer: SupportsWrite[A]
b_writer: SupportsWrite[B]

f(a_iterable, a_writer)
f(b_iterable, b_writer)
f(a_iterable, b_writer) # E: Argument 2 to "f" has incompatible type "SupportsWrite[B]"; expected "SupportsWrite[A]"
f(b_iterable, a_writer)

[case type_var_with_co_and_contra_matrix_reveal_type]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

reveal_type(f(a_co, a_co)) # N: Revealed type is "list[__main__.A]"
reveal_type(f(a_co, b_co)) # N: Revealed type is "list[__main__.A]"
reveal_type(f(b_co, a_co)) # N: Revealed type is "list[__main__.A]"

reveal_type(f(a_contra, a_contra)) # N: Revealed type is "list[__main__.A]"
reveal_type(f(a_contra, b_contra)) # N: Revealed type is "list[__main__.B]"
reveal_type(f(b_contra, a_contra)) # N: Revealed type is "list[__main__.B]"

reveal_type(f(a_co, a_contra)) # N: Revealed type is "list[__main__.A]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "list[Any]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
reveal_type(f(b_co, a_contra)) # N: Revealed type is "list[__main__.B]"
reveal_type(f(a_contra, b_co)) # N: Revealed type is "list[__main__.B]"
reveal_type(f(b_contra, a_co)) # N: Revealed type is "list[Any]" \
                               # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
reveal_type(f(a_co, b_contra)) # N: Revealed type is "list[Any]" \
                               # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case type_var_with_co_and_contra_matrix_no_context]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

f(b_co, a_inv)
f(a_inv, b_co)
f(b_contra, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(a_inv, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
f(a_contra, a_inv)
f(a_co, a_inv)
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
f(b_inv, a_inv) # E: Argument 2 to "f" has incompatible type "Invariant[A]"; expected "Co[B] | Contra[B] | Invariant[B]"


[case type_var_with_co_and_contra_matrix_invariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

a1: list[A] = f(a_co, a_co)
a2: list[A] = f(b_co, b_co)
a3: list[A] = f(c_co, c_co)
a4: list[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[B], Contra[B], Invariant[B]]"
a5: list[B] = f(b_co, b_co)
a6: list[B] = f(c_co, c_co)
a7: list[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a8: list[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]" \
                            # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Union[Co[C], Contra[C], Invariant[C]]"
a9: list[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_invariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: list[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: list[A] = f(c_contra, a_co) # E: Argument 1 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b3: list[A] = f(a_contra, c_co)
b4: list[A] = f(c_co, a_contra)

b5: list[B] = f(b_contra, c_co)
b6: list[B] = f(c_co, b_contra)
b7: list[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: list[B] = f(c_co, a_contra)

[case type_var_with_co_and_contra_matrix_covariant_context_simple]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, a_co)
b2: Iterable[A] = f(b_co, b_co)
b3: Iterable[A] = f(c_co, c_co)
b4: Iterable[B] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b5: Iterable[B] = f(b_co, b_co)
b6: Iterable[B] = f(c_co, c_co)
b7: Iterable[C] = f(a_co, a_co) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b8: Iterable[C] = f(b_co, b_co) # E: Argument 1 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]" \
                                # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
b9: Iterable[C] = f(c_co, c_co)

[case type_var_with_co_and_contra_matrix_covariant_context_complex]
from typing import Generic, TypeVar, Iterable

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)

class Co(Generic[T_co]): pass
class Contra(Generic[T_contra]): pass
class Invariant(Generic[T]): pass

class A: ...
class B(A): ...
class C(B): ...

def f(
    x: Co[T] | Contra[T] | Invariant[T],
    y: Co[T] | Contra[T] | Invariant[T]
) -> list[T]: ...

a_co: Co[A]
b_co: Co[B]
c_co: Co[C]
a_contra: Contra[A]
b_contra: Contra[B]
c_contra: Contra[C]
a_inv: Invariant[A]
b_inv: Invariant[B]
c_inv: Invariant[C]

b1: Iterable[A] = f(a_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"
b2: Iterable[A] = f(c_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[C] | Contra[C] | Invariant[C]"
b3: Iterable[A] = f(a_contra, c_co)
b4: Iterable[A] = f(c_co, a_contra)

b5: Iterable[B] = f(b_contra, c_co)
b6: Iterable[B] = f(c_co, b_contra)
b7: Iterable[B] = f(a_co, b_contra) # E: Argument 1 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
b8: Iterable[B] = f(c_co, a_contra)

c1: Iterable[A] = f(b_contra, c_contra)
c2: Iterable[A] = f(c_contra, b_contra)
c3: Iterable[A] = f(b_contra, a_co) # E: Argument 2 to "f" has incompatible type "Co[A]"; expected "Co[B] | Contra[B] | Invariant[B]"
c4: Iterable[A] = f(a_co, b_contra) # E: Argument 2 to "f" has incompatible type "Contra[B]"; expected "Co[A] | Contra[A] | Invariant[A]"
c5: Iterable[A] = f(b_contra, b_co)
c6: Iterable[A] = f(b_co, b_contra)

d1: Iterable[A] = f(c_co, b_contra)
d2: Iterable[A] = f(b_contra, c_co)
d3: Iterable[A] = f(c_contra, b_co) # E: Argument 2 to "f" has incompatible type "Co[B]"; expected "Co[C] | Contra[C] | Invariant[C]"
d4: Iterable[A] = f(b_co, c_contra) # E: Argument 2 to "f" has incompatible type "Contra[C]"; expected "Co[A] | Contra[A] | Invariant[A]"

[case class_generics_recursion]
from typing import TypeVar
T = TypeVar("T")

class X(list[X[T] | T]): ...  # E: Name "X" is used before definition

foo: X[int] = X([X([1])])
reveal_type(foo) # N: Revealed type is "__main__.X[int]"
reveal_type(foo[0]) # N: Revealed type is "__main__.X[int] | int"

[case nested_tuple_context_inference1]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    return x

def g(x: TupList[T, T]) -> TupList[T, T]:
    return x

f(g([(1, 1)]))
f(g([(1, "")]))
x = [(1, "")]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[int, str]]"; expected "list[tuple[int, int]]"

x1: TupList[object, object] = f(g([(1, 1)]))
x2: TupList[int, int] = f(g([(1, 1)]))
x3: TupList[int, int] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[str, str] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_tuple_context_inference2]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))]))
x = [((1, 1), (1, ""))]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"


x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"

[case nested_tuple_context_inference3]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError
def g(x: TupList[T, T]) -> TupList[tuple[T, T], tuple[T, T]]:
    raise NotImplementedError

f(g([(1, 1)]))
f(g([(1, "")]))
x = [(1, "")]
g(x) # E: Argument 1 to "g" has incompatible type "list[tuple[int, str]]"; expected "list[tuple[int, int]]"

x1: TupList[tuple[object, object], tuple[object, object]] = f(g([(1, 1)]))
x2: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, 1)]))
x3: TupList[tuple[int, int], tuple[int, int]] = f(g([(1, "")])) # E: List item 0 has incompatible type "tuple[int, str]"; expected "tuple[int, int]"
x4: TupList[tuple[str, str], tuple[str, str]] = f(g([(1, 1)])) # E: List item 0 has incompatible type "tuple[int, int]"; expected "tuple[str, str]"

[case nested_tuple_context_inference4]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')

TupList = list[tuple[T, U]]

def f(x: TupList[tuple[T, T], tuple[T, T]]) -> TupList[T, T]:
    raise NotImplementedError
def g(x: TupList[T, U]) -> TupList[T, U]:
    raise NotImplementedError

f(g([((1, 1), (1, 1))]))
f(g([((1, 1), (1, ""))])) # E: Argument 1 to "f" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"
x = [((1, 1), (1, ""))]
f(g(x)) # E: Argument 1 to "f" has incompatible type "list[tuple[tuple[int, int], tuple[int, str]]]"; expected "list[tuple[tuple[int, int], tuple[int, int]]]"

x1: TupList[object, object] = f(g([((1, 1), (1, 1))]))
x2: TupList[int, int] = f(g([((1, 1), (1, 1))]))
x3: TupList[int, int] = f(g([((1, 1), (1, ""))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, str]]"; expected "tuple[tuple[int, int], tuple[int, int]]"
x4: TupList[str, str] = f(g([((1, 1), (1, 1))])) # E: List item 0 has incompatible type "tuple[tuple[int, int], tuple[int, int]]"; expected "tuple[tuple[str, str], tuple[str, str]]"

[case context_inference_with_any]
from typing import TypeVar, Generic, Any
U = TypeVar('U')

class Foo(Generic[U]): ...

T = TypeVar('T', Foo[int], Foo[str])

def f(x: T, y: T) -> list[T]:
    return [x, y]

fi: Foo[int]
fs: Foo[str]
x1: list[Foo[int]] = f(fi, fi)
x2: list[Foo[int]] = f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
x3: list[Foo[int]] = f(fs, fi) # E: Argument 1 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
y1: list[Foo[Any]] = f(fi, fi)
y2: list[Foo[Any]] = f(fs, fs)
f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
y3: list[Foo[Any]] = f(fi, fs) # E: Argument 2 to "f" has incompatible type "Foo[str]"; expected "Foo[int]"
f(fs, fi) # E: Argument 2 to "f" has incompatible type "Foo[int]"; expected "Foo[str]"
y4: list[Foo[Any]] = f(fs, fi) # E: Argument 2 to "f" has incompatible type "Foo[int]"; expected "Foo[str]"

[case generic_covariant_match_mypy_compatible]
# flags: --mypy-compatible
from typing import TypeVar, Sequence

T = TypeVar("T")

def foo(x: T, y: T) -> T: ...

x: list[Sequence[int]]
y: list[Sequence[object]]

reveal_type(foo(x, y)) # N: Revealed type is "typing.Sequence[typing.Sequence[object]]"
reveal_type(foo(y, x)) # N: Revealed type is "typing.Sequence[typing.Sequence[object]]"

[case generic_covariant_match_no_mypy_compatible]
# flags: --no-mypy-compatible
from typing import TypeVar, Sequence

T = TypeVar("T")

def foo(x: T, y: T) -> T: ...

x: list[Sequence[int]]
y: list[Sequence[object]]

reveal_type(foo(x, y)) # N: Revealed type is "list[typing.Sequence[int]] | list[typing.Sequence[object]]"
reveal_type(foo(y, x)) # N: Revealed type is "list[typing.Sequence[object]] | list[typing.Sequence[int]]"

[case class_attribute_inheritance_access]
from typing import TypeVar, Generic

T = TypeVar("T")
U = TypeVar("U")

class A(Generic[T, U]):
    x: tuple[U, T]
class B(A[list[U], tuple[T]]): ...
class C(B[str, float]): ...

reveal_type(A[int, str]().x)  # N: Revealed type is "tuple[str, int]"
reveal_type(B[int, str]().x)  # N: Revealed type is "tuple[tuple[str], list[int]]"
reveal_type(C().x)  # N: Revealed type is "tuple[tuple[float], list[str]]"

[case self_attribute_inheritance_access]
from typing import TypeVar, Generic

T = TypeVar("T")
U = TypeVar("U")

class A(Generic[T, U]):
    def foo(self) -> None:
        self.x: tuple[U, T]
class B(A[list[U], tuple[T]]): ...
class C(B[str, float]): ...

reveal_type(A[int, str]().x)  # N: Revealed type is "tuple[str, int]"
reveal_type(B[int, str]().x)  # N: Revealed type is "tuple[tuple[str], list[int]]"
reveal_type(C().x)  # N: Revealed type is "tuple[tuple[float], list[str]]"

[case different_variances]
from typing import Generic, TypeVar, Callable, List, Sequence

T = TypeVar('T')
T_contra = TypeVar('T_contra', contravariant=True)

class A(Generic[T_contra]): pass
class B(Generic[T]): pass

class C: ...
class D(C): ...

def g(x: Sequence[T], y: Sequence[T]) -> T: ...
def h(x: A[T], y: A[T]) -> T: ...
def i(x: Callable[[Sequence[T]], None], y: Callable[[Sequence[T]], None]) -> T: ...
def j(x: Callable[[A[T]], None], y: Callable[[A[T]], None]) -> T: ...
def k(x: Callable[[Callable[[Sequence[T]], None]], None], y: Callable[[Callable[[Sequence[T]], None]], None]) -> T: ...
def l(x: Callable[[Callable[[A[T]], None]], None], y: Callable[[Callable[[A[T]], None]], None]) -> T: ...

c: Sequence[C]
d: Sequence[D]
ac: A[C]
ad: A[D]
c_c: Callable[[Sequence[C]], None]
c_d: Callable[[Sequence[D]], None]
c_ac: Callable[[A[C]], None]
c_ad: Callable[[A[D]], None]
c_c_c: Callable[[Callable[[Sequence[C]], None]], None]
c_c_d: Callable[[Callable[[Sequence[D]], None]], None]
c_c_ac: Callable[[Callable[[A[C]], None]], None]
c_c_ad: Callable[[Callable[[A[D]], None]], None]

reveal_type(g(c, d))  # N: Revealed type is "__main__.C"
reveal_type(h(ac, ad))  # N: Revealed type is "__main__.D"
reveal_type(i(c_c, c_d))  # N: Revealed type is "__main__.D"
reveal_type(i(c_d, c_c))  # N: Revealed type is "__main__.D"
reveal_type(j(c_ac, c_ad))  # N: Revealed type is "__main__.C"
reveal_type(j(c_ad, c_ac))  # N: Revealed type is "__main__.C"
reveal_type(k(c_c_c, c_c_d))  # N: Revealed type is "__main__.C"
reveal_type(k(c_c_d, c_c_c))  # N: Revealed type is "__main__.C"
reveal_type(l(c_c_ac, c_c_ad))  # N: Revealed type is "__main__.D"
reveal_type(l(c_c_ad, c_c_ac))  # N: Revealed type is "__main__.D"

[case nested_invariance]
from typing import Generic, TypeVar, Sequence

T = TypeVar('T')

class X(Generic[T]): ...
class C: ...
class D(C): ...

def x(x: X[Sequence[T]], y: X[Sequence[T]]) -> T: ...
x_s_c: X[Sequence[C]]
x_s_d: X[Sequence[D]]
x(x_s_c, x_s_d)  # E: Argument 2 to "x" has incompatible type "X[Sequence[D]]"; expected "X[Sequence[C]]"

[case self_generic_filter]
from typing import Generic, TypeVar, overload, Any

T = TypeVar('T')

class X(Generic[T]):
    @overload
    def foo(self: X[int]) -> T: ...
    @overload
    def foo(self: X[int], second: int) -> T: ...
    @overload
    def foo(self: X[float]) -> T: ...
    @overload
    def foo(self: X[str]) -> T: ...
    def foo(self: X[Any], second: int = 1) -> T: ...

x_int: X[int]
x_str: X[str]
x_float: X[float]
x_bytes: X[bytes]
x_any: X[Any]

reveal_type(x_int.foo())  # N: Revealed type is "int"
reveal_type(x_str.foo())  # N: Revealed type is "str"
reveal_type(x_float.foo())  # N: Revealed type is "float"
reveal_type(x_any.foo())  # N: Revealed type is "Any"

reveal_type(x_int.foo(1))  # N: Revealed type is "int"
x_str.foo(1)  # E: Too many arguments for "foo" of "X"

x_bytes.foo()  # E: Invalid self argument "type[X[bytes]]" to class attribute function "foo" with type "Callable[[X[int]], T]"

[case type_var_restriction_subtyping]
# flags: --disallow-redefinition
from typing import TypeVar, Generic
X = TypeVar('X', int, str)
class S(str): pass
class C(Generic[X]):
    def __init__(self, x: X) -> None: pass
x = C("")
y = C(S())
if int():
    x = y
    y = x
c_int = C(1) # type: C[int]
if int():
    y = c_int # E: Incompatible types in assignment (expression has type "C[int]", variable has type "C[str]")

[case self_type_property_with_generics]
from typing import TypeVar, Generic

T = TypeVar("T")
class Foo(Generic[T]):
    @property
    def f(self: Foo[int]) -> T: raise NotImplementedError

foo: Foo[int]
bar: Foo[str]
reveal_type(foo.f)  # N: Revealed type is "int"
reveal_type(bar.f)  # E: Invalid self argument "Foo[str]" to attribute function "f" with type "Callable[[Foo[int]], T]" \
                    # N: Revealed type is "Any"

[case self_type_var_tuple_not_fixed]
from typing import TypeVar, TypeVarTuple, Generic

T = TypeVar("T")
Ts = TypeVarTuple("Ts")
class Foo(Generic[T, *Ts]):
    def f(self: Foo[int, *Ts]) -> tuple[T, *Ts]: ...

foo: Foo[int, bytes, float]
bar: Foo[str, bytes, float]
reveal_type(foo.f())  # N: Revealed type is "tuple[int, bytes, float]"
bar.f()  # E: Invalid self argument "Foo[str, bytes, float]" to attribute function "f" with type "Callable[[Foo[int, Unpack[Ts]]], tuple[T, Unpack[Ts]]]"

[case self_type_var_tuple_init_not_fixed]
from typing import TypeVar, TypeVarTuple, Generic

T = TypeVar("T")
Ts = TypeVarTuple("Ts")
class Foo(Generic[T, *Ts]):
    def __init__(self: Foo[int, *Ts], *args: *Ts) -> None: ...


bar: Foo[str, bytes, float]
reveal_type(Foo(b'', 1.0))  # N: Revealed type is "__main__.Foo[int, Literal[b'']?, float]"

[case generic_method_on_class_access_no_overload]
from typing import TypeVar, Generic, Self, Tuple

T = TypeVar('T')
U = TypeVar('U', bound=int)

class Foo(Generic[T]):
    def foo(self: Self, t: T, u: U) -> Tuple[Self, T, U]: ...

reveal_type(Foo.foo)  # N: Revealed type is "def [T, Self <: __main__.Foo[T], U <: int] (self: Self, t: T, u: U) -> Tuple[Self, T, U]"

fooi: Foo[int]
reveal_type(Foo.foo(fooi, "", 1))  # N: Revealed type is "tuple[__main__.Foo[int], str, int]"
reveal_type(Foo.foo(fooi, b"", 1))  # N: Revealed type is "tuple[__main__.Foo[int], object, int]"

[case generic_method_on_class_access_overload]
from typing import TypeVar, Generic, Self, overload, Tuple

T = TypeVar('T')
U = TypeVar('U', bound=int)

class Foo(Generic[T]):
    @overload
    def bar(self: Self, t: T, u: U) -> Tuple[Self, T, U]: ...
    @overload
    def bar(self: Self, t: T, u: U, q: int) -> Tuple[Self, T, U]: ...
    def bar(self: Self, t: T, u: U, q: int | None = None) -> Tuple[Self, T, U]: ...

reveal_type(Foo.bar)  # N: Revealed type is "Overload(def [T, Self <: __main__.Foo[T], U <: int] (self: Self, t: T, u: U) -> Tuple[Self, T, U], def [T, Self <: __main__.Foo[T], U <: int] (self: Self, t: T, u: U, q: int) -> Tuple[Self, T, U])"

fooi: Foo[int]
reveal_type(Foo.bar(fooi, "", 1))  # N: Revealed type is "tuple[__main__.Foo[int], str, int]"
reveal_type(Foo.bar(fooi, b"", 1))  # N: Revealed type is "tuple[__main__.Foo[int], object, int]"

[case nested_late_bound_type_vars]
from typing import TypeVar, Callable
B = TypeVar("B", bound=int)
B2 = TypeVar("B2", bound=int)
T = TypeVar("T")
def foo(x: T, c: Callable[[B, B], None]) -> None: ...

def same(x: int, y: int) -> None: ...
def same_wrong(x: str, y: str) -> None: ...
def other(x: int, y: str) -> None: ...
foo(1.0, same)
foo(1.0, same_wrong)  # E: Value of type variable "B" of "foo" cannot be "str"
foo(1.0, other)  # E: Value of type variable "B" of "foo" cannot be "str"

def tv1(x: B, y: B2) -> None: ...
def tv2(x: B2, y: B2) -> None: ...
foo(1.0, tv1)
foo(1.0, tv2)

[case nested_late_bound_type_vars2]
from typing import TypeVar, Callable
B = TypeVar("B", bound=int)
B2 = TypeVar("B2", bound=int)
T = TypeVar("T")
def foo(x: T, c: Callable[[B, B], B]) -> None: ...

def same(x: int, y: int) -> int: ...
def same_wrong(x: str, y: str) -> str: ...
def other(x: int, y: str) -> object: ...
foo(1.0, same)
foo(1.0, same_wrong)  # E: Value of type variable "B" of "foo" cannot be "str"
foo(1.0, other)  # E: Value of type variable "B" of "foo" cannot be "str"

def tv1(x: B, y: B2) -> B2: ...
def tv2(x: B2, y: B2) -> B2: ...
foo(1.0, tv1)
foo(1.0, tv2)

[case nested_late_bound_type_vars3]
from typing import TypeVar, Callable
B = TypeVar("B", bound=int)
def foo(c: Callable[[B], B]) -> None: ...

def same(x: int) -> int: ...
def same_wrong(y: str) -> str: ...
def other(x: int) -> object: ...
foo(same)
foo(same_wrong)  # E: Value of type variable "B" of "foo" cannot be "str"
foo(other)  # E: Value of type variable "B" of "foo" cannot be "object"

[case transitive_constraints_pick_correct_bound]
# A bit like testInferenceAgainstGenericBoundsAndValues, but another case as
# well.
from typing import TypeVar, Callable, List

class A: ...
class B(A): ...
class C(B): ...

UA = TypeVar('UA', bound=A)
UB = TypeVar('UB', bound=B)
UC = TypeVar('UC', bound=C)
T = TypeVar("T")

def dec1(f: Callable[[UA], T]) -> Callable[[UA], List[T]]: ...
def dec2(f: Callable[[UC], T]) -> Callable[[UC], List[T]]: ...
def id1(x: UB) -> UB: ...

reveal_type(dec1(id1))  # N: Revealed type is "def [UB <: __main__.B] (UB) -> list[UB]"
reveal_type(dec2(id1))  # N: Revealed type is "def [UC <: __main__.C] (UC) -> list[UC]"

[case transitive_constraints_avoid_same_function_tv_confusion]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")

def combine(f: Callable[[T1], T1], g: Callable[[T2], int]) -> Callable[[T1, T2], Tuple[T1, T2]]: ...
def id1(x: T3) -> T3: ...
def id2(x: T4) -> T4: ...

reveal_type(combine(id1, id2))  # N: Revealed type is "def [T1] (T1, int) -> tuple[T1, int]"
reveal_type(combine(id1, id1))  # N: Revealed type is "def [T1] (T1, int) -> tuple[T1, int]"

[case transitive_constraints_type_var_tuple_propagation1]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Us]], Unpack[Ts]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], Tuple[Unpack[Us]]]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Vs]) -> Tuple[int, str]: ...
def connect2(x: Tuple[Unpack[Vs]], y: str, z: int) -> Tuple[Unpack[Vs]]: ...
def connect3(x: Tuple[bytes, str], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def (int, str) -> tuple[int, str]"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, int) -> tuple[str, int]"
reveal_type(dec(connect3))  # N: Revealed type is "def [Ts] (*Unpack[Ts]) -> tuple[bytes, str]"

[case transitive_constraints_type_var_tuple_propagation2]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Us]], Unpack[Us]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Us]], Tuple[Unpack[Ts]]]: ...

def connect1(x: Tuple[Unpack[Vs]], y: int, z: str) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[str, int], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...
def connect3(x: Tuple[Unpack[Vs]], *args: Unpack[Vs]) -> Tuple[bytes, str]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def (int, str) -> tuple[int, str]"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, int) -> tuple[str, int]"
reveal_type(dec(connect3))  # N: Revealed type is "def [Us] (*Unpack[Us]) -> tuple[bytes, str]"

[case transitive_constraints_type_var_tuple_propagation_reverse1]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec1(f: Callable[[Tuple[int, str], Unpack[Ts]], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], None]: ...
def dec2(f: Callable[[Tuple[Unpack[Ts]], Unpack[Ts]], Tuple[str, int]]) -> Callable[[Unpack[Ts]], None]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Us]) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[Unpack[Us]], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec1(connect1))  # N: Revealed type is "def (int, str)"
reveal_type(dec2(connect1))  # N: Revealed type is "def (str, int)"

reveal_type(dec1(connect2))  # N: Revealed type is "def [Ts] (*Unpack[Ts])"
reveal_type(dec2(connect2))  # N: Revealed type is "def (str, int)"

[case transitive_constraints_type_var_tuple_propagation_reverse2]
from typing import TypeVarTuple, Callable, Tuple, Unpack

Ts = TypeVarTuple("Ts")
Us = TypeVarTuple("Us")
Vs = TypeVarTuple("Vs")

def dec(f: Callable[[Tuple[Unpack[Ts]], str, bytes], Tuple[Unpack[Ts]]]) -> Callable[[Unpack[Ts]], None]: ...

def connect1(x: Tuple[Unpack[Vs]], *args: Unpack[Us]) -> Tuple[Unpack[Vs]]: ...
def connect2(x: Tuple[Unpack[Us]], *args: Unpack[Vs]) -> Tuple[Unpack[Vs]]: ...

reveal_type(dec(connect1))  # N: Revealed type is "def [Ts] (*Unpack[Ts])"
reveal_type(dec(connect2))  # N: Revealed type is "def (str, bytes)"

[case transitive_free_type_vars_without_callable]
from typing import TypeVar, Callable, List

T1 = TypeVar("T1")
T2 = TypeVar("T2")

def foo(f: Callable[[T1], T1]) -> T1: ...
def id(x: T2) -> T2: ...

reveal_type(foo(id))  # N: Revealed type is "Never"

[case transitive_constraints_mismatch1_mypy_compatible]
# flags: --mypy-compatible
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")

def combine(f: Callable[[T1, T2], T3], g: T2, h: T3) -> Callable[[T1], T3]: ...
def id(x: T4, y: T4) -> T4: ...

reveal_type(combine(id, 1, ""))  # N: Revealed type is "def (object) -> object"

[case transitive_constraints_mismatch1_no_mypy_compatible]
# flags: --no-mypy-compatible
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
T4 = TypeVar("T4")

def combine(f: Callable[[T1, T2], T3], g: T2, h: T3) -> Callable[[T1], T3]: ...
def id(x: T4, y: T4) -> T4: ...

# TODO currently not deterministic
-- reveal_type(combine(id, 1, ""))  # N: Revealed type is "def (str | int) -> int | str"
x: Callable[[int | str], int | str] = combine(id, 1, "")

[case transitive_constraints_mismatch2]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")

def combine(f: Callable[[T1, T1], T2], h: T2) -> Callable[[T1], T2]: ...
def id(x: T3, y: int) -> T3: ...

x = combine(id, "")  # E: Incompatible callable argument with type vars
reveal_type(x)  # N: Revealed type is "def (Any) -> Any"

[case transitive_constraints_mismatch3]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")

def combine(f: Callable[[List[T1]], List[T1]]) -> Callable[[T1], T1]: ...
def id(x: List[T2]) -> List[List[T2]]: ...

x = combine(id)  # E: Incompatible callable argument with type vars
reveal_type(x)  # N: Revealed type is "def (Any) -> Any"

[case transitive_constraints_recursive_match]
from typing import TypeVar, Callable, List, Tuple

T1 = TypeVar("T1")
T2 = TypeVar("T2")

def combine(f: Callable[[List[T1]], List[T1]]) -> Callable[[T1], T1]: ...
def id(x: List[List[int]]) -> List[List[T2]]: ...

x = combine(id)
reveal_type(x)  # N: Revealed type is "def (list[int]) -> list[int]"

[case transitive_constraints_any_correctly_applied]
from typing import TypeVar, Callable, List, Tuple, Any

T1 = TypeVar("T1")
T2 = TypeVar("T2")

def foo1(f: Callable[[List[T1]], Any]) -> Callable[[T1], T1]: ...
def id1(x: List[T2]) -> List[T2]: ...

reveal_type(foo1(id1))  # N: Revealed type is "def (Any) -> Any"

def foo2(f: Callable[[List[T1]], List[T1]]) -> Callable[[T1], T1]: ...
def id2(x: List[T2]) -> Any: ...

reveal_type(foo2(id2))  # N: Revealed type is "def (Any) -> Any"

[case type_var_meets_object]
from typing import TypeVar

T = TypeVar("T")

def foo(x: T, y: object) -> T | object: ...

reveal_type(foo(1, ''))  # N: Revealed type is "object"

def bar(x: T | object) -> T: ...

reveal_type(bar(1))  # N: Revealed type is "Never"

[case generic_callable_in_classdef]
from typing import TypeVar, Generic, Callable

T = TypeVar("T")
class Foo(Generic[T]):
    x: T

reveal_type(Foo[Callable[[int], str]]().x(1))  # N: Revealed type is "str"
reveal_type(Foo[Callable[[T], T]]().x(1))  # N: Revealed type is "int"

[case infer_lambda_invariant_generics]
# Like testIsinstanceInInferredLambda but with invariant generics (lists)
from typing import TypeVar, Callable, Optional, List
T = TypeVar('T')
S = TypeVar('S')
class A: pass
class B(A): pass
class C(A): pass
def f(func: Callable[[T], S], *z: T, r: Optional[List[S]] = None) -> S: pass
f(
    lambda x:  # E: Argument 1 to "f" has incompatible type "Callable[[A], A]"; expected "Callable[[A], B]"
        B() if isinstance(x, B) else x,
    A(), r=[B()])

[case avoid_recursive_self_type_var_lookup]
# Partially copied from testRejectCovariantArgumentInLambda
from typing import TypeVar, Generic, Callable, List, Set

t = TypeVar('t', covariant=True)
class Thing(Generic[t]):
    def chain(self, l: List[t]) -> None: pass
    def end(self) -> None:
        return self.chain(1)  # E: Argument 1 to "chain" of "Thing" has incompatible type "int"; expected "list[t]"

class Other(Thing[Set[t]]):
    def end2(self) -> None:
        self.chain([1])  # E: List item 0 has incompatible type "int"; expected "set[t]"
        return self.chain(1)  # E: Argument 1 to "chain" of "Thing" has incompatible type "int"; expected "list[set[t]]"

class Other2(Thing[t]):
    def end2(self) -> None:
        self.chain([1])  # E: List item 0 has incompatible type "int"; expected "t"
        return self.chain(1)  # E: Argument 1 to "chain" of "Thing" has incompatible type "int"; expected "list[t]"

[case __new__super_class_generics]
from typing import Iterator, TypeVar, Iterable, Self

T = TypeVar('T')

class container(Iterable[T]):
    def __new__(cls, sequence: list[T], /) -> Iterable[T]: ...  # E: Incompatible return type for "__new__" (returns "Iterable[T]", but must return a subtype of "container")
    def __iter__(self) -> Iterator[T]: ...

def foo(x: list[int]) -> None:
    reveal_type(container(x))  # N: Revealed type is "__main__.container[int]"

[case set_generics_with_any]
from typing import Any
Alias = tuple[Any, ...]
x: set[Alias] = set()

[case bound_generics_no_mismatches]
from typing import TypeVar, Any, Sequence
T = TypeVar('T', bound=Sequence[Any])

class A: ...
class B(A): ...
class C(B): ...

def foo(x: T, y: T) -> T: ...

def bar(x: Sequence[int], y: Sequence[str]) -> None:
    foo(x, x)
    foo(x, y)
    z: Sequence[object] = foo(x, y)

def baz(x: Sequence[B], y: Sequence[C]) -> None:
    z: Sequence[A] = foo(x, y)


[case upper_and_lower_bound_for_contravariant_matching]
from typing import TypeVar, Callable
T = TypeVar('T')

class A: ...
class B(A): ...
class C(B): ...

def foo(x: T, y: Callable[[T, T], None]) -> T: ...

def baz(x: C, y: Callable[[C, B], None]) -> None:
    reveal_type(foo(x, y))  # N: Revealed type is "__main__.C"
    z: A = foo(x, y)

[case avoid_recursion_on_type_var_nesting_in_list_inference]
# This used to lead to stack overflows
from typing import Callable, TypeVar, Any
T = TypeVar("T")
U = TypeVar("U")
def foo(x: T) -> T:
    def bar(x: U, y: T) -> U: ...

    bar(1, [])  # E: Argument 2 to "bar" has incompatible type "list[Never]"; expected "T"
    return x

[case defaultdict_like_getitem]
from typing import Callable, TypeVar, Any
_KT = TypeVar("_KT")
_VT = TypeVar("_VT")
class X(dict[_KT, _VT]):
    def __init__(self, c: Callable[[], _VT]) -> None: ...

def foo(a: Any) -> None:
    reveal_type(X(list)[a])  # N: Revealed type is "list[Never]"
    reveal_type(X(list[int])[a])  # N: Revealed type is "list[int]"

y = X(list)  # E: Need type annotation for "y"
reveal_type(y)  # N: Revealed type is "__main__.X[Any, list[Any]]"
y[[]].append(1)

[case dict_get_with_context]
def foo(x: dict[int, str]) -> str | None:
    return x.get(1, None)

[case optional_type_var_matching_with_covariant_context]
from typing import TypeVar, Callable
T = TypeVar("T")

def wrap(lookup: Callable[[], T]) -> T | None: ...
def get() -> int | None: ...

def run() -> int | None:
    return wrap(get)

[case invariant_generics_in_comparison_with_union_any]
from typing import Any
def foo(x: list[int | Any], y: list[int]) -> None:
    if bool():
        x = y
    if bool():
        y = x

[case type_var_tuple_merging_join]
# flags: --use-joins
from typing import TypeVarTuple, TypeVar, Generic, Tuple, Unpack

Ts = TypeVarTuple("Ts")
T = TypeVar("T")
class Foo(Generic[Unpack[Ts]]): ...

class A: ...
class B(A): ...
class C(B): ...
def f(x: Foo[A, B, C, C], y: Foo[C, B, B, A], z: Foo[C, B], other: Foo[int]):
    reveal_type(g(x, y))  # N: Revealed type is "__main__.Foo[__main__.A, __main__.B, __main__.B, __main__.A]"
    reveal_type(g(y, x))  # N: Revealed type is "__main__.Foo[__main__.A, __main__.B, __main__.B, __main__.A]"

    reveal_type(g(x, z))  # N: Revealed type is "__main__.Foo[Unpack[Tuple[__main__.A, ...]]]"
    reveal_type(g(z, x))  # N: Revealed type is "__main__.Foo[Unpack[Tuple[__main__.A, ...]]]"

    reveal_type(g(x, other))  # N: Revealed type is "__main__.Foo[Unpack[Tuple[__main__.A | int, ...]]]"
    reveal_type(g(other, x))  # N: Revealed type is "__main__.Foo[Unpack[Tuple[int | __main__.A, ...]]]"

def g(x: T, y: T) -> T: ...

[case type_var_tuple_merging_no_join]
# flags: --no-use-joins
from typing import TypeVarTuple, TypeVar, Generic, Tuple, Unpack

Ts = TypeVarTuple("Ts")
T = TypeVar("T")
class Foo(Generic[Unpack[Ts]]): ...

class A: ...
class B(A): ...
class C(B): ...
def f(x: Foo[A, B, C, C], y: Foo[C, B, B, A], z: Foo[C, B], other: Foo[int]):
    reveal_type(g(x, y))  # N: Revealed type is "__main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C] | __main__.Foo[__main__.C, __main__.B, __main__.B, __main__.A]"
    reveal_type(g(y, x))  # N: Revealed type is "__main__.Foo[__main__.C, __main__.B, __main__.B, __main__.A] | __main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C]"

    reveal_type(g(x, z))  # N: Revealed type is "__main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C] | __main__.Foo[__main__.C, __main__.B]"
    reveal_type(g(z, x))  # N: Revealed type is "__main__.Foo[__main__.C, __main__.B] | __main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C]"

    reveal_type(g(x, other))  # N: Revealed type is "__main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C] | __main__.Foo[int]"
    reveal_type(g(other, x))  # N: Revealed type is "__main__.Foo[int] | __main__.Foo[__main__.A, __main__.B, __main__.C, __main__.C]"

def g(x: T, y: T) -> T: ...

[case param_spec_merging_join]
# flags: --use-joins
from typing import ParamSpec, TypeVar, Generic

P = ParamSpec("P")
T = TypeVar("T")
class Foo(Generic[P]): ...

class A: ...
class B(A): ...
class C(B): ...
def f(x: Foo[[A, B, C, C]], y: Foo[[C, B, B, A]], z: Foo[[C, B]]):
    reveal_type(g(x, y))  # N: Revealed type is "__main__.Foo[[__main__.C, __main__.B, __main__.C, __main__.C]]"
    reveal_type(g(y, x))  # N: Revealed type is "__main__.Foo[[__main__.C, __main__.B, __main__.C, __main__.C]]"

    reveal_type(g(x, z))  # N: Revealed type is "object"
    reveal_type(g(z, x))  # N: Revealed type is "object"

def g(x: T, y: T) -> T: ...

[case param_spec_merging_no_join]
# flags: --no-use-joins
from typing import ParamSpec, TypeVar, Generic

P = ParamSpec("P")
T = TypeVar("T")
class Foo(Generic[P]): ...

class A: ...
class B(A): ...
class C(B): ...
def f(x: Foo[[A, B, C, C]], y: Foo[[C, B, B, A]], z: Foo[[C, B]]):
    reveal_type(g(x, y))  # N: Revealed type is "__main__.Foo[[__main__.A, __main__.B, __main__.C, __main__.C]] | __main__.Foo[[__main__.C, __main__.B, __main__.B, __main__.A]]"
    reveal_type(g(y, x))  # N: Revealed type is "__main__.Foo[[__main__.C, __main__.B, __main__.B, __main__.A]] | __main__.Foo[[__main__.A, __main__.B, __main__.C, __main__.C]]"

    reveal_type(g(x, z))  # N: Revealed type is "__main__.Foo[[__main__.A, __main__.B, __main__.C, __main__.C]] | __main__.Foo[[__main__.C, __main__.B]]"
    reveal_type(g(z, x))  # N: Revealed type is "__main__.Foo[[__main__.C, __main__.B]] | __main__.Foo[[__main__.A, __main__.B, __main__.C, __main__.C]]"

def g(x: T, y: T) -> T: ...

[case avoid_recursion_when_dealing_with_same_class_generics]
from typing import Generic, Iterable, TypeVar

T = TypeVar("T")

class OrderedSet(Generic[T]):
    def union(self, same: OrderedSet[T], other: Iterable[T]):
        same |= other

    def __ior__(self, other: Iterable[T]) -> OrderedSet[T]: ...

[case self_generics_with_unions_no_crash]
class X[T](list[T]):
    def update(self, x: T) -> None: ...

    def f[S](self: X[T | S], iterable: S) -> X[T | S]:
        self.update(iterable)
        # TODO This should not error, but at the moment I'm just happy it does not crash
        return self # E: Incompatible return value type (got "X[T | S]", expected "X[T | S]")

[case own_generics_inversion_should_not_panic]
from typing import TypeVar, Generic, Any
KT = TypeVar("KT")
VT = TypeVar("VT")

class Dct(Generic[KT, VT]):
    def inverse(self) -> Dct[VT, KT]: ...
    def pop(self, key: KT) -> VT: ...
    def popitem(self, x: Any) -> KT:
        return self.inverse().pop(x)

[case class_type_var_with_forward_reference]
from typing import TypeVar
T = TypeVar('T')

class X(list['T']): ...

def f(x: X[int]):
    reveal_type(x)  # N: Revealed type is "__main__.X[int]"

[case param_spec_alias_usage_with_forward_reference]
from typing import Callable, TypeVar, Union, ParamSpec, TypeGuard, Awaitable

P = ParamSpec('P')
T = TypeVar('T')
MaybeAwaitable = Union[T, list[T]]
MaybeAwaitableFunc = Callable[P, 'MaybeAwaitable[T]']

def g(f: MaybeAwaitableFunc[[int, str], int]):
    pass

[case origin_of_same_callable_should_not_lead_to_type_var_confusion_in_overloads]
from typing import Any, Concatenate, Literal, TypeVar, overload, ParamSpec, Callable

P = ParamSpec("P")
A = TypeVar("A")
B = TypeVar("B")
C = TypeVar("C")
D = TypeVar("D")

def curry(c: Callable[Concatenate[A, P], B]) -> Callable[[A], Callable[P, B]]: ...

@curry
@overload
def mapmap(m: Callable[[], C], p: list[tuple[()]]) -> list[C]: ...

@curry
@overload
def mapmap(m: Callable[[C], D], p: list[tuple[C]]) -> list[D]: ...

# The implementation is weird and just tries to reproduce a bug
@curry  # E: Overloaded function implementation does not accept all possible arguments of signature 2
def mapmap(m: Callable[[], D], p: list[A]) -> list[D]: ...

[case generics_resolving_for_method_access_on_subclass]
from typing import Generic, TypeVar, Callable, Generator

G = TypeVar("G")
SendT_contra = TypeVar("SendT_contra", contravariant=True, default=None)
ReturnT_co = TypeVar("ReturnT_co", covariant=True, default=None)

class Super(Generic[G]):
    def foo(self) -> G: ...

class Sub(Super[Generator[G, SendT_contra, ReturnT_co]]): ...

reveal_type(Sub.foo)  # N: Revealed type is "def [G, SendT_contra = None, ReturnT_co = None] (self: __main__.Super[typing.Generator[Any, None, None]]) -> typing.Generator[G, SendT_contra = None, ReturnT_co = None]"

[case param_spec_with_any_passing]
from typing import TypeVar, Generic, ParamSpec, Callable, Tuple, Dict, Any

_T = TypeVar("_T")
_P = ParamSpec("_P")

class CallLater(Generic[_T]):
    def __init__(self, func: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs):
        self._func: Callable[_P, _T] = func
        self._args: Tuple[Any, ...] = args
        self._kwargs: Dict[str, Any] = kwargs

    def __call__(self) -> _T:
        return self._func(*self._args, **self._kwargs)

def foo(x: int) -> None: ...

x: CallLater[None] = CallLater(foo, 1)
y = CallLater(foo, "")  # E: Argument 2 to "CallLater" has incompatible type "str"; expected "int"
reveal_type(y())  # N: Revealed type is "None"

[case class_method_generics_with_type_var_in_class_scope]
# Copied from testGenericClassAlternativeConstructorPreciseOverloaded with valid cases
from typing import Generic, TypeVar, Type, Tuple, overload, Union

T = TypeVar('T')

class Base(Generic[T]):
    Q = TypeVar('Q', bound=Base[T])

    @overload
    @classmethod
    def make_some(cls: Type[Q], item: T) -> Q: ...

    @overload
    @classmethod
    def make_some(cls: Type[Q], item: T, n: int) -> Tuple[Q, ...]: ...

    @classmethod
    def make_some(cls: Type[Q], item: T, n: int = 0) -> Union[Q, Tuple[Q, ...]]: ...

class Sub(Base[str]): ...
Sub.make_some(1)  # E: Invalid self argument "type[Sub]" to attribute function "make_some" with type "overloaded function"
Sub.make_some("")

[case type_var_default_fallback_with_syntax]
class C[T=bytes, U=str, V=U, W=V]: ...

def f(
    a: C,
    b: C[int],
    c: C[int, float],
    d: C[int, float, bytes],
) -> None:
    reveal_type(a)  # N: Revealed type is "__main__.C[bytes, str, str, str]"
    reveal_type(b)  # N: Revealed type is "__main__.C[int, str, str, str]"
    reveal_type(c)  # N: Revealed type is "__main__.C[int, float, float, float]"
    reveal_type(d)  # N: Revealed type is "__main__.C[int, float, bytes, bytes]"

type A[T=bytes, U=str, V=U, W=V] = tuple[T, U, V, W]

def g(
    a: A,
    b: A[int],
    c: A[int, float],
    d: A[int, float, bytes],
) -> None:
    reveal_type(a)  # N: Revealed type is "tuple[bytes, str, str, str]"
    reveal_type(b)  # N: Revealed type is "tuple[int, str, str, str]"
    reveal_type(c)  # N: Revealed type is "tuple[int, float, float, float]"
    reveal_type(d)  # N: Revealed type is "tuple[int, float, bytes, bytes]"

[case type_var_default_fallback_with_old_style]
from typing import Generic, TypeVar

T = TypeVar("T", default=bytes)
U = TypeVar("U", default=str)
V = TypeVar("V", default=U)
W = TypeVar("W", default=V)
class C(Generic[T, U, V, W]): ...

def f(
    a: C,
    b: C[int],
    c: C[int, float],
    d: C[int, float, bytes],
) -> None:
    reveal_type(a)  # N: Revealed type is "__main__.C[bytes, str, str, str]"
    reveal_type(b)  # N: Revealed type is "__main__.C[int, str, str, str]"
    reveal_type(c)  # N: Revealed type is "__main__.C[int, float, float, float]"
    reveal_type(d)  # N: Revealed type is "__main__.C[int, float, bytes, bytes]"

A = tuple[T, U, V, W]

def g(
    a: A,
    b: A[int],
    c: A[int, float],
    d: A[int, float, bytes],
) -> None:
    reveal_type(a)  # N: Revealed type is "tuple[bytes, str, str, str]"
    reveal_type(b)  # N: Revealed type is "tuple[int, str, str, str]"
    reveal_type(c)  # N: Revealed type is "tuple[int, float, float, float]"
    reveal_type(d)  # N: Revealed type is "tuple[int, float, bytes, bytes]"

[case invalid_type_var_default_usage_with_default_syntax]
class ClassError1[T3=str, T1]: ...  # E: "T1" cannot appear after "T3" in type parameter list because it has no default type

def func_error1(
    a: ClassError1,
    b: ClassError1[int],
    c: ClassError1[int, float],
) -> None:
    reveal_type(a)  # N: Revealed type is "__main__.ClassError1[str, Any]"
    reveal_type(b)  # N: Revealed type is "__main__.ClassError1[int, Any]"
    reveal_type(c)  # N: Revealed type is "__main__.ClassError1[int, float]"

    k = ClassError1()
    reveal_type(k)  # N: Revealed type is "__main__.ClassError1[str, Any]"
    l = ClassError1[int]()
    reveal_type(l)  # N: Revealed type is "__main__.ClassError1[int, Any]"
    m = ClassError1[int, float]()
    reveal_type(m)  # N: Revealed type is "__main__.ClassError1[int, float]"

class ClassError2[T4=T3, T3=str]: ...  # E: Type parameter "T4" has a default type that refers to one or more type variables that are out of scope

def func_error2(
    a: ClassError2,
    b: ClassError2[int],
    c: ClassError2[int, float],
) -> None:
    reveal_type(a)  # N: Revealed type is "__main__.ClassError2[Any, str]"
    reveal_type(b)  # N: Revealed type is "__main__.ClassError2[int, str]"
    reveal_type(c)  # N: Revealed type is "__main__.ClassError2[int, float]"

    k = ClassError2()
    reveal_type(k)  # N: Revealed type is "__main__.ClassError2[Any, str]"
    l = ClassError2[int]()
    reveal_type(l)  # N: Revealed type is "__main__.ClassError2[int, str]"
    m = ClassError2[int, float]()
    reveal_type(m)  # N: Revealed type is "__main__.ClassError2[int, float]"

type TERR1[T3=str, T1] = dict[T3, T1]  # E: "T1" cannot appear after "T3" in type parameter list because it has no default type

def func_error_alias1(
    a: TERR1,
    b: TERR1[int],
    c: TERR1[int, float],
) -> None:
    reveal_type(a)  # N: Revealed type is "dict[str, Any]"
    reveal_type(b)  # N: Revealed type is "dict[int, Any]"
    reveal_type(c)  # N: Revealed type is "dict[int, float]"

type TERR2[T4=T3, T3=str] = dict[T4, T3]  # E: Type parameter "T4" has a default type that refers to one or more type variables that are out of scope

def func_error_alias2(
    a: TERR2,
    b: TERR2[int],
    c: TERR2[int, float],
) -> None:
    reveal_type(a)  # N: Revealed type is "dict[Any, str]"
    reveal_type(b)  # N: Revealed type is "dict[int, str]"
    reveal_type(c)  # N: Revealed type is "dict[int, float]"

[case different_file_class_should_not_crash]
from m import P
class C:
    def __init__(self) -> None:
        P()

[file m.py]
from typing import TypeVar, Generic

T = TypeVar("T", bound=str | None)

class A(Generic[T]): ...
class P(A[T]): ...

[case type_var_default_complex_fallback]
class C[T=list[U], U=str]: ...  # E: Type parameter "T" has a default type that refers to one or more type variables that are out of scope

def func_error2(
    a: C,
    b: C[int],
    c: C[int, float],
) -> None:
    reveal_type(a)  # N: Revealed type is "__main__.C[list[Any], str]"
    reveal_type(b)  # N: Revealed type is "__main__.C[int, str]"
    reveal_type(c)  # N: Revealed type is "__main__.C[int, float]"

[case no_crash_on_self_access_for_class_with_type_var_values]
import typing
T = typing.TypeVar("T", str, bytes)

class C(typing.Generic[T]):
    def __init__(self, t: T) -> None:
        self.t = t
        # TODO this should emit a note
        reveal_type(t)

def f(c: C):
    c.t

[case strict_equality_class_generics_access]
# flags: --strict-equality
from typing import Any, Generic, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")

class C(Generic[U]):
    def __init_subclass__(cls) -> None:
        if C in cls.__bases__ and (cls.new == C.new):
            ...

    @overload
    def new(self, x: int) -> C[T]: ...
    @overload
    def new(self, x: str) -> C[Any]: ...
    def new(self, x) -> C[Any]: ...

[case generic_usage_of_class_in_class_should_not_cause_stack_overflow]
from typing import Generic, TypeVar, Callable

_InT = TypeVar('_InT')
_OutT = TypeVar('_OutT')
_NewOutT = TypeVar('_NewOutT')

class Pipeline(Generic[_InT, _OutT]):
    def predicate(self: Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Pipeline[_InT, _NewOutT]: ...

    def str_starts_with(self: Pipeline[_InT, str], prefix: str) -> Pipeline[_InT, str]:
        return self.predicate(lambda v: v.startswith(prefix))

[case no_crash_on_param_spec_type_var_tuple_alias_definitions]
from typing import TypeVar, Generic, ParamSpec, TypeVarTuple
T = TypeVar('T')
P = ParamSpec('P')
Ts = TypeVarTuple('Ts')

class PandT(Generic[P, T]):
    pass

C1 = PandT[P, T]
x1: C1[[int, str], bool]
reveal_type(x1)  # N: Revealed type is "__main__.PandT[[int, str], bool]"

C2 = PandT[[int, T], T]
x2: C2[str]
reveal_type(x2)  # N: Revealed type is "__main__.PandT[[int, str], str]"

C3 = PandT[[int, *Ts], T]
x3: C3[str, bool, bytes]
reveal_type(x3)  # N: Revealed type is "__main__.PandT[[int, str, bool], bytes]"

[case lambda_isinstance_should_not_crash]
from m import Super

class C(Super[int]): ...

x = lambda message: isinstance(message, C) and message.foo == 1

reveal_type(x(1))  # N: Revealed type is "bool"
reveal_type(x(C(1)))  # N: Revealed type is "bool"
reveal_type(C(1).foo) # N: Revealed type is "int"
C("")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"

[file m.py]
from typing import Generic, TypeVar

if bool(): ...

T = TypeVar("T")
U = TypeVar("U")

class Sub(Generic[U]):
    def __init__(self, foo: U):
        self.foo = foo

class Super(Sub[T]):
    foo: T

[case context_inference_for_unions_again_empty_literals_should_not_result_in_never]
def f() -> list[int] | list[str]:
    return []

def g() -> set[int] | set[str]:
    return set()

def h() -> dict[int, int] | dict[str, str]:
    return {}

[case unrestricted_type_of_typevar]
# Copied from conformance tests (constructors_call_type.py)
from typing import TypeVar
T = TypeVar("T")
def f(cls: type[T]):
    cls()  # OK
    cls(1)  # E: Too many arguments for "object"

[case set_generics_inference]
a = set(('a', 'b'))
z = set(('z',))

reveal_type(a)  # N: Revealed type is "set[str]"
reveal_type(z)  # N: Revealed type is "set[str]"

for s in a:
    pass

for s in z:  # Redefining s here should be fine, see also #36
    pass
